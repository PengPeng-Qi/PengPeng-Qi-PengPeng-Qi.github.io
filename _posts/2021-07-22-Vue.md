## 前言
以下是我结合前面的知识以及本文的相关内容所写的demo
- 1、[简易计算器](/demo/Vue/简易计算器.html)
- 2、[选项卡案例](/demo/Vue/选项卡案例.html)
- 3、[验证用户名是否可用](/demo/Vue/验证用户名是否可用.html)
- 4、[图书管理](/demo/Vue/图书管理案例.html)
- 5、[列表过滤实现模糊搜索](/demo/Vue/列表过滤模糊搜索.html)

## Vue基础
### Vue概述
Vue：渐进式JavaScript框架 
### Vue基本使用
Vue代码 --> Vue框架 --> 原生js代码
### Vue模版语法
模板 + 数据 --> 前端渲染 == 静态HTML内容  
  
> `Vue.config.productionTip = false` 阻止 vue 在启动时生成生产提示。
  
#### data
`data`有两种写法:  
- 1、对象式
- 2、声明式

```js
new Vue({
  el:'#root',
  //data的第一种写法：对象式
  data:{
    name:'尚硅谷'
  }

  //data的第二种写法：函数式，组件式开发必须使用函数式
  /*   data(){
      console.log('@@@',this) //此处的this是Vue实例对象
      return{
        name:'尚硅谷'
      }
    } */
})
```

> 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了

#### 指令
指令的本质是自定义属性，指令的格式：以`v-`开头(`v-cloak`)  
##### v-cloak
插值表达式存在的问题：‘闪动’，可使用`v-cloak`解决，原理：**先隐藏，替换好值之后再显示最终的值**。
```html
<!-- v-cloak指令的用法
1、提供样式
  [v-cloak]{
    display: none;
  }
2、在插值表达式所在的标签中添加v-cloak指令 -->
<style type="text/css">
[v-cloak]{
  display: none;
}
</style>

  <div id="app">
  <div v-cloak>{{msg}}</div>
</div>
```
##### 数据绑定指令
- `v-text`：填充纯文本
- `v-html`：存在安全问题，本网站内部数据可以使用，来自第三方的数据不可以用
- `v-pre`：填充原始信息(跳过编译部分)

```html
<div>{{msg}}</div>
<div v-text='msg'></div>
<div v-html='msg1'></div>
<div v-pre>{{msg}}</div>
```
##### 数据响应式
数据响应式：数据的变化导致页面内容的变化。  
  
数据绑定：将数据填充到标签中。
#### 双向数据绑定指令
双向绑定一般**应用在表单类元素**上，如(input、select等)、`v-model:value`可以简写为`v-model`，因为`v-model`默认收集的就是value值。  
  
`v-model`指令用法：`<input type="text" v-model:value="uname" />`  
简写为：`v-model`指令用法：`<input type="text" v-model="uname" />`
```html
<div>
  <input type="text" v-model='msg'>
</div>
```
##### MVVM思想
- M：model、data中的数据
- V：view、模版代码
- VM：View-Model、Vue实例(vm)

data所有的属性最后都出现在了vm身上。
#### 数据代理
##### 回顾defineProperty属性
```js
let number = 18
let person = {
  name:'张三',
  sex:'男',
}

Object.defineProperty(person,'age',{
  // value:18,
  // enumerable:true, //控制属性是否可以枚举，默认值是false
  // writable:true, //控制属性是否可以被修改，默认值是false
  // configurable:true //控制属性是否可以被删除，默认值是false

  //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
  get(){
    console.log('有人读取age属性了')
    return number
  },

  //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值，具体的值为value
  set(value){
    console.log('有人修改了age属性，且值是',value)
    number = value
  }

})

// console.log(Object.keys(person))  返回数组

console.log(person)
```
##### 数据代理
```js
let obj = {x:100}
let obj2 = {y:200}

Object.defineProperty(obj2,'x',{
  get(){
    return obj.x
  },
  set(value){
    obj.x = value
  }
})
```
##### Vue中的数据代理
- 1.Vue中的数据代理：
  - 通过vm对象来代理data对象中属性的操作（读/写）
- 2.Vue中数据代理的好处：
  - 更加方便的操作data中的数据
- 3.基本原理：
  - 通过`Object.defineProperty()`把data对象中所有属性添加到vm上。
  - 为每一个添加到vm上的属性，都指定一个`getter/setter`。
  - 在`getter/setter`内部去操作（读/写）data中对应的属性。

#### 事件绑定
`v-on`指令用法：`<input type=‘button' v-on:click='num++'/>`  
`v-on`简写用法：`<input type=‘button' @click='num++'/>`  

```html
<button v-on:click='num++'>点击</button>
<button @click='num++'>点击1</button>
```
##### 事件函数的调用方式
直接绑定属性名称：`<button v-on:click='say'>Hello</button>`  
调用函数：`<button v-on:click='say()'>Say hi</button>`  
```html
<button @click='handle'>点击2</button>
<button @click='handle()'>点击3</button>

<script type="text/javascript">
  var vm = new Vue({
      el: '#app',
      data: {
          num: 0
      }, 
      // 注意点： 这里不要忘记加逗号 
      // methods 中主要是定义一些函数
      methods: {
        // 可简写为handle(){}
          handle: function() {
              // 这里的this是Vue的实例对象+
              console.log(this === vm)
              // 如果这里是箭头函数的话，this就是window
              // 在函数中想要使用data里面的数据 一定要加this 
              this.num++;
          }
      }
  });
</script>
```
> methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象

##### 事件函数参数传递
普通参数和事件对象：`<button v-on:click='say("hi",$event)'>Say hi</button>`
```html
<div id="app">
    <div>{{num}}</div>
    <div>
        <!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 -->
        <button v-on:click='handle1'>点击1</button>
        <!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，
              并且事件对象的名称必须是$event 
        -->
        <button v-on:click='handle2(123, 456, $event)'>点击2</button>
    </div>
</div>
<script type="text/javascript">
    var vm = new Vue({
        el: '#app',
        data: {
            num: 0
        },
        methods: {
            handle1: function(event) {
                console.log(event.target.innerHTML) // 点击1
            },
            handle2: function(p, p1, event) {
                console.log(p, p1)                  // 123 456
                console.log(event.target.innerHTML) // 点击2
                this.num++;
            }
        }
    });
</script>
```
##### 事件修饰符
- `.stop`阻止冒泡：`<a v-on:click.stop="handle">跳转</a>`
- `.prevent`阻止默认行为：`<a v-on:click.prevent="handle">跳转</a>`
- `v-once`：只编译一次，显示内容不再具有响应式功能。  

```html
<!-- 
    Vue中的事件修饰符：
        1.prevent：阻止默认事件（常用）；
        2.stop：阻止事件冒泡（常用）；
        3.once：事件只触发一次（常用）；
        4.capture：使用事件的捕获模式；
        5.self：只有event.target是当前操作的元素时才触发事件；
        6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
-->
<div id="app">
  <div>{{num}}</div>
  <div v-on:click='handle0'>
    <button v-on:click.stop='handle1'>点击1</button>
  </div>
  <div>
    <!-- 修饰符可以连写 -->
    <a href="http://www.baidu.com" v-on:click.prevent='handle2'>百度</a>
  </div>
  <div v-once>{{info}}</div>
</div>
```
##### 按钮修饰符
- `.enter`回车键：`<input v-on:keyup.enter='submit'>`
- `.delete`删除键：`<input v-on:keyup.delete='handle'>` 

```html
<!-- 
    1.Vue中常用的按键别名：
          回车 => enter
          删除 => delete (捕获“删除”和“退格”键)
          退出 => esc
          空格 => space
          换行 => tab (特殊，必须配合keydown去使用)
          上 => up
          下 => down
          左 => left
          右 => right

    2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）

    3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
          (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
          (2).配合keydown使用：正常触发事件。

    4.也可以使用keyCode去指定具体的按键（不推荐）

    5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
-->
<div id="app">
  <form action="">
    <div>
      用户名：
      <input type="text" v-on:keyup.delete='clearContent' v-model='uname'>
    </div>
    <div>
      密码：
      <input type="text" v-on:keyup.f1='handleSubmit' v-model='pwd'>
    </div>
    <div>
      <input type="button" v-on:click='handleSubmit' value="提交">
    </div>
  </form>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      uname: '',
      pwd: '',
      age: 0
    },
    methods: {
      clearContent:function(){
        // 按delete键的时候，清空用户名
        this.uname = '';
      },
      handleSubmit: function(){
        console.log(this.uname,this.pwd)
      }
    }
  });
</script>
```
##### 自定义按键修饰符
全局`config.keyCodes`对象，`Vue.config.keyCodes.f1 = 112`

```html
<div id="app">
  <input type="text" v-on:keyup.aaa='handle' v-model='info'>
</div>
<script type="text/javascript">
  /*
    规则：自定义按键修饰符名字是自定义的，但是对应的值必须是按键对应event.keyCode值
  */
  Vue.config.keyCodes.aaa = 65 // 必须按keyCode为65的键， aaa可以随意设置
  var vm = new Vue({
    el: '#app',
    data: {
      info: ''
    },
    methods: {
      handle: function(event){
        console.log(event.keyCode)
      }
    }
  });
</script>
```
#### 属性绑定
`v-bind`指令用法：`<a v-bind:href='url'>跳转</a>`，绑定之后里面的值当作JS表达式，所以`url`是一个JS表达式，值在`vm`中  
缩写：`<a :href='url'>跳转</a>`  
```html
<div id="app">
  <a v-bind:href="url">百度</a>
  <a :href="url">百度1</a>
  <button v-on:click='handle'>切换</button>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      url: 'http://www.baidu.com'
    },
    methods: {
      handle: function(){
        // 修改URL地址
        this.url = 'https://pengpeng-qi.github.io/';
      }
    }
  });
</script>
```
##### v-model的底层实现原理分析
`<input v-bind:value="msg" v-on:input="msg=$event.target.value">`
```html
<div id="app">
  <div>{{msg}}</div>
  // 三种方式同效
  <input type="text" v-bind:value="msg" v-on:input='handle'>
  <input type="text" v-bind:value="msg" v-on:input='msg=$event.target.value'>
  <input type="text" v-model='msg'>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      msg: 'hello'
    },
    methods: {
      handle: function(event){
        // 使用输入域中的最新的数据覆盖原来的数据
        this.msg = event.target.value;
      }
    }
  });
</script>
```
#### 样式绑定
class样式处理：  
- 字符串语法：`<div :class='xxx'>`、用于类名不确定，需要动态获取
- 对象语法：`<div v-bind:class="{active: isActive}"></div>`  
- 数组语法：`<div v-bind:class="[activeClass, errorClass]"></div>`
  
style样式处理：
- 对象语法：`<div v-bind:style="{color: activeColor, fontSize: fontSize}"></div>`
- 数组语法：`<div v-bind:style="[baseStyle, overridingStyles]"></div>`

```html
<body>
  <div id="root">
    <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
    <div class="basic" :class="mood" @click="changeMood">{{name}}</div> <br/><br/>

    <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定，操作样式数组 -->
    <div class="basic" :class="classArr">{{name}}</div> <br/><br/>
    <!-- 下面这种不常使用 -->
    <!-- <div class="basic" :class="['atguigu1','atguigu2','atguigu3']">{{name}}</div> <br/><br/> -->
    <!-- 注意数组里记得加引号，如果没加引号需要在data里面配置，例如[a, b, c], data里面应该是a: 'atguigu1'.... -->

    <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->
    <div class="basic" :class="classObj">{{name}}</div> <br/><br/>

    <!-- 绑定style样式-不常用-对象写法 -->
    <div class="basic" :style="styleObj">{{name}}</div> <br/><br/>
      <!-- <div class="basic" :style="fontSize: fizes +'px'">{{name}}</div> <br/><br/> -->
      <!-- fizes需要在data中赋值 -->
    <!-- 绑定style样式-不常用-数组写法 -->
    <div class="basic" :style="styleArr">{{name}}</div>
    <!-- :style="[a,b]"其中a、b是样式对象 -->
  </div>
</body>

<script type="text/javascript">
  Vue.config.productionTip = false
  
  const vm = new Vue({
    el:'#root',
    data:{
      name:'尚硅谷',
      mood:'normal',
      classArr:['atguigu1','atguigu2','atguigu3'],
      classObj:{
        atguigu1:false,
        atguigu2:false,
      },
      styleObj:{
        fontSize: '40px', // 注意不是font-size
        color:'red',
      },
      styleArr:[
        {
          fontSize: '40px',
          color:'blue',
        },
        {
          backgroundColor:'gray' // 大驼峰
        }
      ]
    },
    methods: {
      changeMood(){
        const arr = ['happy','sad','normal']
        const index = Math.floor(Math.random()*3)
        this.mood = arr[index]
      }
    },
  })
</script>
```
#### 分支循环结构
##### 分支结构
- 1、`v-if`
- 2、`v-else`
- 3、`v-else-if`
- 4、`v-show`

```html
<div id="app">
  <div v-if='score>=90'>优秀</div>                <!-- 不显示 -->
  <div v-else-if='score<90&&score>=80'>良好</div> <!-- 不显示 -->
  <div v-else-if='score<80&&score>60'>一般</div>  <!-- 不显示 -->
  <div v-else>比较差</div>
  <div v-show='flag'>测试v-show</div>             <!-- 不显示 -->
  <button v-on:click='handle'>点击</button>

  <!-- v-if与template的配合使用，v-show不能-->
  <template v-if="n === 1">
    <h2>你好</h2>
    <h2>北京</h2>
  </template>
	<button v-on:click='n++'>点击n++</button>
</div>
<script type="text/javascript">
  /*
    v-show的原理：控制元素样式是否显示 display:none
  */
  var vm = new Vue({
    el: '#app',
    data: {
      score: 10,
      flag: false,
      n: 0
    },
    methods: {
      handle: function(){
        this.flag = !this.flag;
      }
    }
  });
</script>
```
`v-if`与`v-show`的区别：
- `v-if`控制元素**是否渲染到页面**、实质是控制DOM元素
- `v-show`控制元素**是否显示**(已经渲染到了页面)、适合频繁切换显示模式

##### 循环结构
- 1、`v-for`：遍历数组，用于展示列表数据
  - `<li v-for='item in list'>{{item}}</li>`
  - `<li v-for='(item,index) in list'>{{item}} + '---' +{{index}}</li>`
- 2、key的作用：帮助Vue区分不同的元素，从而提高性能，常使用id
  - `<li :key='item.id' v-for='(item, index) in list'>{{item}} + --- + {{index}}</li>`
- 3、遍历对象
  - `<div v-for='(value, k, index) in object' :key="k"></div>`

```html
  <div id="app">
    <div>水果列表</div>
    <ul>
      <!-- 简单数组 -->
      <li v-for='item in fruits'>{{item}}</li>
      <li v-for='(item, index) in fruits'>{{item + '---' + index}}</li>

      <!-- 数组中有对象 -->
      <!-- 如果item没有id，可以使用index，但不推荐使用index -->
      <li :key='item.id' v-for='(item, index) in myFruits'>
        <span>{{item.ename}}</span>   <!-- item是数组中的每一项 -->
        <span>{{item.cname}}</span>
      </li>

    </ul>
  </div>
  <script type="text/javascript">
    var vm = new Vue({
      el: '#app',
      data: {
        fruits: ['apple', 'orange', 'banana'],
        myFruits: [{
          id: 1,
          ename: 'apple',
          cname: '苹果'
        },{
          id: 2,
          ename: 'orange',
          cname: '橘子'
        },{
          id: 3,
          ename: 'banana',
          cname: '香蕉'
        }]
      }
    });
  </script>
```
遍历对象：
```html
<!-- v-if v-for结合使用 -->
<div id="app">
  <div v-if='v==13' v-for='(v,k,i) in obj'>{{v + '---' + k + '---' + i}}</div>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      obj: {
        uname: 'zhangsan',
        age: 13,
        gender: 'female'
      }
    }
  });
</script>
```
##### key的原理
虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：  
  
对比规则：
- (1).旧虚拟DOM中找到了与新虚拟DOM相同的key： 
  - ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！
  - ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。
- (2).旧虚拟DOM中未找到与新虚拟DOM相同的key
  - 创建新的真实DOM，随后渲染到到页面。
  
用index作为key可能会引发的问题：
- 1.若对数据进行：逆序添加、逆序删除等破坏顺序操作:
  - 会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。
- 1.如果结构中还包含输入类的DOM：
  - 会产生错误DOM更新 ==> 界面有问题。

开发中如何选择key?:
- 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
- 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。

![遍历列表key的作用-id为key](https://raw.githubusercontent.com/PengPeng-Qi/PengPeng-Qi.github.io/main/img/%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8%E6%97%B6key%E7%9A%84%E4%BD%9C%E7%94%A8id%E4%B8%BAkey.png)
![遍历列表key的作用-index为key](https://raw.githubusercontent.com/PengPeng-Qi/PengPeng-Qi.github.io/main/img/%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8%E6%97%B6key%E7%9A%84%E4%BD%9C%E7%94%A8index%E4%B8%BAkey.png)
### Vue常用特性
#### 表单操作
- input
- textarea
- select
- radio
- checkbox

```html
<div id="app">
  <form action="http://itcast.cn">
    <div>
      <span>姓名：</span>
      <span>
        <input type="text" v-model='uname'>
      </span>
    </div>
    <div>
      <span>性别：</span>
      <span>
        <input type="radio" id="male" value="1" v-model='gender'>
        <label for="male">男</label>
        <input type="radio" id="female" value="2" v-model='gender'>
        <label for="female">女</label>
      </span>
    </div>
    <div>
      <span>爱好：</span>
      <input type="checkbox" id="ball" value="1" v-model='hobby'>
      <label for="ball">篮球</label>
      <input type="checkbox" id="sing" value="2" v-model='hobby'>
      <label for="sing">唱歌</label>
      <input type="checkbox" id="code" value="3" v-model='hobby'>
      <label for="code">写代码</label>
    </div>
    <div>
      <span>职业：</span>
      <select v-model='occupation' multiple>
        <option value="0">请选择职业...</option>
        <option value="1">教师</option>
        <option value="2">软件工程师</option>
        <option value="3">律师</option>
      </select>
    </div>
    <div>
      <span>个人简介：</span>
      <textarea v-model='desc'></textarea>
    </div>
    <div>
      <input type="submit" value="提交" @click.prevent='handle'>
    </div>
  </form>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      uname: 'lisi',          // 默认值lisi
      gender: 2,              // 默认第二个被选中
      hobby: ['2','3'],       // 默认第二、三个被选中
      // occupation: 3        // 默认选择第三个
      occupation: ['2','3'],  // 默认第二、三个被选中
      desc: 'nihao'           // 默认值nihao
    },
    methods: {
      handle: function(){
        // console.log(this.uname)
        // console.log(this.gender)
        // console.log(this.hobby.toString())
        // console.log(this.occupation)
        console.log(this.desc)
      }
    }
  });
</script>
```
可通过[这个](/demo/Vue/表单基本操作.html)查看  
表单域修饰符：
- number：转化为数值
- trim：去掉开始和结尾的空格
- lazy：将input事件(表单内数值发送改变就会触发)切换为change(失去焦点才会发送触发)事件

`<input v-model.number="age" type="number">`
#### 自定义指令
**自定义指令的语法规则**(获取元素焦点)：
```js
Vue.directive('focus' {
  inserted: function(el) {
  // 获取元素的焦点
    el.focus();
  }
})
```
**自定义指令用法**：
```js
<input type="text" v-focus>
```
**带参数的自定义指令**：
```html
<div id="app">
  <input type="text" v-color='msg'>
</div>
<script type="text/javascript">
  Vue.directive('color', {
    bind: function(el, binding){
      // 根据指令的参数设置背景色
      el.style.backgroundColor = binding.value.color;
    }
  });
  var vm = new Vue({
    el: '#app',
    data: {
      msg: {
        color: 'blue'
      }
    },
  });
</script>
```
**局部指令**：
```js
var vm = new Vue({
  el: '#app',
  data: {
    msg: {
      color: 'red'
    }
  },
  directives: {
    color: {
      bind: function(el, binding){
        el.style.backgroundColor = binding.value.color;
      }
    },
    focus: {
      inserted: function(el) {
        el.focus();
      }
    }
  }
});
```
#### 计算属性
**定义**：要用的属性不存在，要通过**已有属性**计算得来。   
**原理**：底层借助了`Objcet.defineproperty`方法提供的`getter`和`setter`。  
  
get函数在**初次读取**的时候以及**依赖的数据发送变化**时会执行。  
  
和`methods`相比，内部有**缓存**机制，**当多个地方调用该计算属性时，不用再次计算**，效率更高。  
  
计算属性最终会出现在vm上，直接读取使用即可
```html
<body>
  <div id="root">
    姓：<input type="text" v-model="firstName"> <br/><br/>
    名：<input type="text" v-model="lastName"> <br/><br/>
    全名：<span>{{fullName}}</span> <br/><br/>
  </div>
</body>
<script type="text/javascript">
  const vm = new Vue({
    el:'#root',
    data:{
      firstName:'张',                   // 属性
      lastName:'三',                    // vm._date 里有data里的值，但是没有计算属性,计算属性最终会出现在vm上
    },
    computed:{                          // 计算属性可能会有多个，所以用对象包起来
      // fullName:{                        // 通过对属性计算得出的属性，注意计算属性是属性，调用的时候不能把它视为对象调用
      //   get(){                          // 当fullName被读取的时候，get就会被调用，返回值就是fullName的值
      //     // console.log(this)          //此处的this是vm
      //     return this.firstName + '-' + this.lastName
      //   },
      //   set(value){                     // 当有人修改fullName()(演示可在控制台中通过vm.fullName修改)调用set()
      //     const arr = value.split('-')  // 修改之后的值传递给set(value)的value
      //     this.firstName = arr[0]       // 令data中的属性赋值为修改后的属性，
      //     this.lastName = arr[1]        // fullName()里的firstName和lastName才会改变至fullName的值才会发送改变
      //   }
      // }

      //简写，当不使用set()时,计算属性大部分时间不用修改
      fullName(){ // fullName: function(){
        console.log('get被调用了')
        return this.firstName + '-' + this.lastName
      }
    }
  })
</script>
```
#### 监视属性
数据一旦发生变化就通知侦听器所绑定方法  
```html
<body>
  <div id="root">
    <h2>今天天气很{{info}}</h2>
    <button @click="changeWeather">切换天气</button>
  </div>
</body>

<script type="text/javascript">
  Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
  
  const vm = new Vue({
    el:'#root',
    data:{
      isHot:true,
    },
    computed:{
      info(){
        return this.isHot ? '炎热' : '凉爽'
      }
    },
    methods: {
      changeWeather(){
        this.isHot = !this.isHot
      }
    },
    watch:{                           // 监视配置
      isHot:{                         // 想监视什么属性，写下需要监视的属性名
        // immediate:true,            // 初始化时让handler调用一下
        handler(newValue,oldValue){   // 当isHot发生改变时，handler发生调用
          console.log('isHot被修改了',newValue,oldValue)
          // newValue：修改后的值
          // oldValue：修改前的值
        }
      }
    } 
  })

  // 写法二
  // vm.$watch('isHot',{
  //   immediate:true, //初始化时让handler调用一下
  //   //handler什么时候调用？当isHot发生改变时。
  //   handler(newValue,oldValue){
  //     console.log('isHot被修改了',newValue,oldValue)
  //   }
  // })
</script>
```
##### 深度监视
```html
<body>
  <div id="root">
    <h3>a的值是:{{numbers.a}}</h3>
    <button @click="numbers.a++">点我让a+1</button>
  </div>
</body>
<script type="text/javascript">
  
  const vm = new Vue({
    el:'#root',
    data:{
      numbers:{
        a:1,
        b:1
      }
    },
    watch:{              // Vue中的watch默认不监测对象内部值的改变（一层）。
      //监视多级结构中某个属性的变化
      // 'numbers.a':{   // key是字符串，所以这里不能简写
      //   handler(){
      //     console.log('a被改变了')
      //   }
      // }

      //监视多级结构中所有属性的变化
      numbers:{         // numbers是简写形式，完整是[numbers]
        deep:true,      // 开启深度监测，配置deep:true可以监测对象内部值改变（多层）
        handler(){
          console.log('numbers改变了')
        }
      }
    }
  })
</script>
```
> Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！

##### 监视属性的简写
```js
// 局部监测
// 正常写法
// isHot:{
//   // immediate:true, //初始化时让handler调用一下
//   // deep:true,//深度监视
//   handler(newValue,oldValue){
//     console.log('isHot被修改了',newValue,oldValue)
//   }
// },

//简写,当配置项只需要handler的时候
isHot(newValue,oldValue){
  console.log('isHot被修改了',newValue,oldValue)
}

// 全局监测
// 正常写法
// vm.$watch('isHot',{
//   immediate:true, //初始化时让handler调用一下
//   deep:true,//深度监视
//   handler(newValue,oldValue){
//     console.log('isHot被修改了',newValue,oldValue)
//   }
// })

//简写
vm.$watch('isHot',function(newValue,oldValue){
  console.log('isHot被修改了',newValue,oldValue)
})
```
##### 计算属性与监视器的区别：
1、computed能完成的功能，watch都可以完成。  
2、watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。  
```html
<body>
  <div id="root">
    姓：<input type="text" v-model="firstName"> <br/><br/>
    名：<input type="text" v-model="lastName"> <br/><br/>
    全名：<span>{{fullName}}</span> <br/><br/>
  </div>
</body>

<script type="text/javascript">
  const vm = new Vue({
    el:'#root',
    data:{
      firstName:'张',
      lastName:'三',
      fullName:'张-三'
    },
    watch:{
      firstName(val){
        // setTimeout()的this指向window，所以这里需要使用箭头函数
        setTimeout(()=>{
          console.log(this) // vue实例
          this.fullName = val + '-' + this.lastName
        },1000); // 等一秒再显示
      },
      lastName(val){
        this.fullName = this.firstName + '-' + val
      }
    }
  })
</script>
```
具体案例可见[验证用户名是否可用](/demo/Vue/验证用户名是否可用.html)
#### 过滤器
格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等.  
  
自定义过滤器：
```js
Vue.filter(‘过滤器名称’, function(value){ 
  // 过滤器业务逻辑
})
```
```html
<div id="app">
  <input type="text" v-model='msg'>
  <div>{{msg | upper}}</div>
  <!-- 级联操作，先对upper过滤然后将结果进行lower过滤 -->
  <div>{{msg | upper | lower}}</div>
  <!-- 属性绑定 -->
  <div :abc='msg | upper'>测试数据</div>
</div>
<script type="text/javascript">
  /*
    过滤器
    1、可以用与插值表达式和属性绑定
    2、支持级联操作
  */
  // Vue.filter('upper', function(val) {
  //   return val.charAt(0).toUpperCase() + val.slice(1);
  // });
  Vue.filter('lower', function(val) {
    return val.charAt(0).toLowerCase() + val.slice(1);
  });
  var vm = new Vue({
    el: '#app',
    data: {
      msg: ''
    },
    filters: {
      upper: function(val) {
        return val.charAt(0).toUpperCase() + val.slice(1);
      }
    }
  });
</script>
```
#### 生命周期
主要阶段：
- 1、挂载
  - `beforeCreate`：在实例化初始之后，数据观测和事件配置之前被调用
  - `created`：实例创建完成之后被立即调用
  - `beforeMount`：挂载开始之前被调用
  - `mounted`：el被新创建的`vm.$el`替换，并挂载到实例上去之后调用该钩子
- 2、更新
  - `beforeUpdate`：数据更新时调用，发生在虚拟DOM打补丁之前
  - `updated`：数据更换导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子
- 3、销毁
  - `beforeDestory`：实例销毁之前调用
  - `destoryed`：实例销毁后调用

### 综合案例
#### 变异方法
会修改原始数据
- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

#### 替换数组
生成新数组
- `filter()`
- `concat()`
- `slice()`

#### 修改响应式数据
- `Vue.set(vm.items, indexOfItem, newValue)`
- `vm.$set(vm.items, indexOfItem, newValue)`
  - 1 参数一表示要处理的数组名称 
  - 2 参数二表示要处理的数组的索引 
  - 3 参数三表示要处理的数组的值
 
```html
<div id="app">
  <ul>
    <li v-for='item in list'>{{item}}</li>
  </ul>
  <div>
    <div>{{info.name}}</div>
    <div>{{info.age}}</div>
    <div>{{info.gender}}</div>
  </div>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      list: ['apple', 'orange', 'banana'],
      info: {
        name: 'lisi',
        age: 12
      }
    },
  });
  // 操作数组
  // vm.list[1] = 'lemon'; // 值被修改，但是不会响应式显示在页面上
  vm.$set(vm.list, 1, 'lemon');  // 响应式显示在页面上

  // 操作对象
  // vm.info.gender = 'male'; // 值被修改，但是不会响应式显示在页面上
  vm.$set(vm.info, 'gender', 'female'); 
  </script>
```
## Vue组件化开发
### 组件注册
#### 全局组件注册语法
```js
Vue.component(组件名称, {
  data: 组件数据,
  template: 组件模版内容
})
```
注册一个名为`button-counter`的新组件
```js
// 组件命名方式可使用短横线方式、或者驼峰方式
// 多个组件可以互相使用，但是在根组件中只能使用短横线方式
Vue.component('button-counter', {
  // 组件 data必须是一个函数
  data: function() {
    return {
      count: 0
    }
  },
  // 组件模块内容必须是单个根元素，也可以是模版字符串
  template: '<div><button v-on:click="count++">点击了{{ count++ }}次</button><button>按钮</button></div>'

  // 组件模版内容也可以是模版字符串
  // template: 
  // `<div>
  //   <button v-on:click="count++">点击了{{ count++ }}次</button>
  //   <button>按钮</button>
  // </div>`,

})
```
#### 局部组件注册
```js
var ComponentA = { /* ... */ } 
var ComponentB = { /* ... */ } 
var ComponentC = { /* ... */ } 
new Vue({
  el: '#app' 
  components: {
  'component-a': ComponentA, 
  'component-b': ComponentB, 
  'component-c': ComponentC,
  } 
})
```
局部组件只能在注册他的父组件中使用
```html
<div id="app">
  <hello-world></hello-world>
  <hello-tom></hello-tom>
  <hello-jerry></hello-jerry>
  <test-com></test-com>
</div>
<script type="text/javascript">
  /*
    局部组件注册
    局部组件只能在注册他的父组件中使用
  */
  Vue.component('test-com',{
    template: '<div>Test<hello-world></hello-world></div>' 
    // 不会显示hello-world组件的信息
  });
  var HelloWorld = {
    data: function(){
      return {
        msg: 'HelloWorld'
      }
    },
    template: '<div>{{msg}}</div>'
  };
  var HelloTom = {
    data: function(){
      return {
        msg: 'HelloTom'
      }
    },
    template: '<div>{{msg}}</div>'
  };
  var HelloJerry = {
    data: function(){
      return {
        msg: 'HelloJerry'
      }
    },
    template: '<div>{{msg}}</div>'
  };
  var vm = new Vue({
    el: '#app',
    data: {
      
    },
    components: {
      'hello-world': HelloWorld,
      'hello-tom': HelloTom,
      'hello-jerry': HelloJerry
    }
  });
</script>
```
### 组件间数据交互
#### 父组件向子组件传值
组件内部通过`props`接收传递过来的值
```js
Vue.component('menu-item', {
  props: ['title'],
  template: '<div>{{ title }}</div>'
})
```
父组件通过属性将值传递给子组件：
```html
<!-- 静态的方式 -->
<menu-item title="来自父组件的数据"></menu-item> 

<!-- 动态的方式，进行属性绑定,父组件 -->
<menu-item :title="title"></menu-item>
```
父组件向子组件传值-基本使用
```html
<div id="app">
  <div>{{pmsg}}</div>
  <menu-item title='来自父组件的值'></menu-item>
  <!-- 动态title + 静态content -->
  <menu-item :title='ptitle' content='hello'></menu-item>
</div>
<script type="text/javascript">
    // 子组件
  Vue.component('menu-item', {
    props: ['title', 'content'],
    data: function() {
      return {
        msg: '子组件本身的数据'
      }
    },
    template: '<div>{{msg + "----" + title + "-----" + content}}</div>'
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      ptitle: '动态绑定属性'
    }
  });
</script>
```
props属性名规则：
- 1、在props中使用驼峰形式，模版中需要使用短横线的形式
- 2、字符串形式的模版中没有这个限制

```html
<div id="app">
  <div>{{pmsg}}</div>
  <!-- :menu-title 在模版中需要使用短横线的形式 -->
  <menu-item :menu-title='ptitle'></menu-item>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  Vue.component('third-com', {
    props: ['testTile'],
    template: '<div>{{testTile}}</div>'
  });
  Vue.component('menu-item', {
    // 在props中使用驼峰形式
    props: ['menuTitle'],
    // testTile 在字符串里面可以使用驼峰的形式
    template: '<div>{{menuTitle}}<third-com testTile="hello"></third-com></div>'
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      ptitle: '动态绑定属性'
    }
  });
</script>
```
**props属性值类型**：
- 字符串string
- 数值Number
- 布尔值Boolean
- 数组Array
- 对象Object

```html
<div id="app">
  <div>{{pmsg}}</div>
  <!-- number、boolean加了：进行绑定得到的是对应的类型，如果没加则为字符串类型  -->
  <menu-item :pstr='pstr' :pnum='12' pboo='true' :parr='parr' :pobj='pobj'></menu-item>
</div>
<script type="text/javascript">
  Vue.component('menu-item', {
    props: ['pstr','pnum','pboo','parr','pobj'],
    template: `
      <div>
        <div>{{pstr}}</div>
        <div>{{12 + pnum}}</div>
        <div>{{typeof pboo}}</div>  
        <ul>
          <li :key='index' v-for='(item,index) in parr'>{{item}}</li>
        </ul>
          <span>{{pobj.name}}</span>
          <span>{{pobj.age}}</span>
        </div>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      pstr: 'hello',
      parr: ['apple','orange','banana'],
      pobj: {
        name: 'lisi',
        age: 12
      }
    }
  });
</script>
```
#### 子组件向父组件传值
子组件通过自定义事件向父组件传递信息：
```html
<button v-on:click='$emit("enlarge-text") '>扩大字体</button>
```
父组件监听子组件的事件：
```html
<menu-item v-on:enlarge-text='fontSize += 0.1'></menu-item>
```
```html
<div id="app">
  <div :style='{fontSize: fontSize + "px"}'>{{pmsg}}</div>
  <!-- 父组件 -->
  <menu-item @enlarge-text='handle'></menu-item>
</div>
<script type="text/javascript">   
  // 子组件 
  Vue.component('menu-item', {
    template: `
      <div>
        <button @click='$emit("enlarge-text")'>扩大父组件中字体大小</button>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      fontSize: 10
    },
    methods: {
      handle: function(){
        // 扩大字体大小
        this.fontSize += 5;
      }
    }
  });
</script>
```
子组件通过自定义事件向父组件传递信息：
```html
<button v-on:click='$emit("enlarge-text", 0.1) '>扩大字体</button>
```
父组件监听子组件的事件：
```html
<menu-item v-on:enlarge-text='fontSize += $event'></menu-item>
```
```html
<div id="app">
  <div :style='{fontSize: fontSize + "px"}'>{{pmsg}}</div>
  <!-- 父组件 -->
  <menu-item @enlarge-text='handle($event)'></menu-item>
</div>
<script type="text/javascript">   
  // 子组件 
  Vue.component('menu-item', {
    template: `
      <div>
        <button @click='$emit("enlarge-text", 5)'>扩大父组件中字体大小</button>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      fontSize: 10
    },
    methods: {
      handle: function(val){
        // 扩大字体大小
        this.fontSize += val;
      }
    }
  });
</script>
```
#### 非父组件间传值
单独的事件中心管理组件间的通信：
```js
var eventHub = new Vue()
```
监听事件与销毁事件：
```js
eventHub.$on('add-todo', addTodo)
eventHub.$off('add-todo')
```
触发事件：
```js
eventHub.$emit('add-todo', id)
```
```html
  <div id="app">
    <div>父组件</div>
    <div>
      <button @click='handle'>销毁事件</button>
    </div>
    <test-tom></test-tom>
    <test-jerry></test-jerry>
  </div>
  <script type="text/javascript">
    /*
      兄弟组件之间数据传递
    */
    // 提供事件中心
    var hub = new Vue();

    Vue.component('test-tom', {
      data: function(){
        return {
          num: 0
        }
      },
      template: `
        <div>
          <div>TOM:{{num}}</div>
          <div>
            <button @click='handle'>点击</button>
          </div>
        </div>
      `,
      methods: {
        handle: function(){
          hub.$emit('jerry-event', 2);
        }
      },
      mounted: function() {
        // 监听事件
        hub.$on('tom-event', (val) => {
          this.num += val;
        });
      }
    });
    Vue.component('test-jerry', {
      data: function(){
        return {
          num: 0
        }
      },
      template: `
        <div>
          <div>JERRY:{{num}}</div>
          <div>
            <button @click='handle'>点击</button>
          </div>
        </div>
      `,
      methods: {
        handle: function(){
          // 触发兄弟组件的事件
          hub.$emit('tom-event', 1);
        }
      },
      mounted: function() {
        // 监听事件
        hub.$on('jerry-event', (val) => {
          this.num += val;
        });
      }
    });
    var vm = new Vue({
      el: '#app',
      data: {
        
      },
      methods: {
        handle: function(){
          hub.$off('tom-event');
          hub.$off('jerry-event');
        }
      }
    });
  </script>
```
### 组件插槽
父组件向子组件传递内容：  
1、插槽位置：  
```js
Vue.component('alert-box', { 
  template: `
    <div class="demo-alert-box"> 
    <strong>Error!</strong> 
    <slot></slot>
    </div> 
    `
})
```
2、插槽内容：
```html
<alert-box>Something bad happened.</alert-box>
```
```html
<div id="app">
  <alert-box>有bug发生</alert-box>   <!-- ERROR:有bug发生 -->
  <alert-box>有一个警告</alert-box>   <!-- ERROR:有bug发生 -->
  <alert-box></alert-box>           <!-- ERROR:默认内容 -->
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  /*
    组件插槽：父组件向子组件传递内容
  */
  Vue.component('alert-box', {
    template: `
      <div>
        <strong>ERROR:</strong>
        <slot>默认内容</slot>
      </div>
    `
  });
```
#### 具名插槽
插槽的定义：
```html
<div class="container">
  <header>
    <slot name="header"></slot> 
  </header>
  <main>
    <slot></slot> 
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```
插槽内容：
```html
<base-layout>
  <h1 slot="header">标题内容</h1>
  <p>主要内容1</p> 
  <p>主要内容2</p>
  <p slot="footer">底部内容</p> 
</base-layout>
```
```html
<div id="app">
  <base-layout>
    <!-- header区域 -->
    <p slot='header'>标题信息</p>
    <!-- main区域 -->
    <p>主要内容1</p>
    <p>主要内容2</p>
    <!-- footer区域 -->
    <p slot='footer'>底部信息信息</p>
  </base-layout>

  <base-layout>
    <!-- header区域 -->
    <template slot='header'>
      <p>标题信息1</p>
      <p>标题信息2</p>
    </template>
    <!-- main区域 -->
    <p>主要内容1</p>
    <p>主要内容2</p>
    <!-- footer区域 -->
    <template slot='footer'>
      <p>底部信息信息1</p>
      <p>底部信息信息2</p>
    </template>
  </base-layout>
</div>
<script type="text/javascript">
  /*
    具名插槽
  */
  Vue.component('base-layout', {
    template: `
      <div>
        <header>
          <slot name='header'></slot>
        </header>
        <main>
          <slot></slot>
        </main>
        <footer>
          <slot name='footer'></slot>
        </footer>
      </div>
    `
  });
```
#### 作用域插槽
父组件对子组件的内容进行加工处理  
  
插槽定义：
```html
<ul>
  <li v-for= "item in list" v-bind:key= "item.id" >
    <!-- 提供一个属性，名字可自定义，值为操作的数据 -->
    <slot v-bind:item="item"> 
      {{item.name}}
     </slot>
  </li>
</ul>
```
插槽内容：
```html
<fruit-list v-bind:list= "list"> 
  <!-- slot-scope得到子组件传过来的数据 -->
  <template slot-scope="slotProps">
    <!-- item是在上面 v-bind绑定的名字 -->
    <strong v-if="slotProps.item.current"> 
      {{ slotProps.item.text }}
    </strong> 
  </template> 
</fruit-list>
```
```html
<div id="app">
  <fruit-list :list='list'>
    <template slot-scope='slotProps'>
      <strong v-if='slotProps.info.id==3' class="current">{{slotProps.info.name}}</strong>
      <span v-else>{{slotProps.info.name}}</span>
    </template>
  </fruit-list>
</div>
<script type="text/javascript">
  Vue.component('fruit-list', {
    props: ['list'],
    template: `
      <div>
        <li :key='item.id' v-for='item in list'>
          <slot :info='item'>{{item.name}}</slot>
        </li>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      list: [{
        id: 1,
        name: 'apple'
      },{
        id: 2,
        name: 'orange'
      },{
        id: 3,
        name: 'banana'
      }]
    }
  });
</script>
```