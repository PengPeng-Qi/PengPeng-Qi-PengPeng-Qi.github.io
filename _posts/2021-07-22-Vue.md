## 前言
以下是我结合前面的知识以及本文的相关内容所写的demo
- 1、[简易计算器](/demo/Vue/简易计算器.html)
- 2、[选项卡案例](/demo/Vue/选项卡案例.html)
- 3、[验证用户名是否可用](/demo/Vue/验证用户名是否可用.html)
- 4、[图书管理](/demo/Vue/图书管理案例.html)

## Vue基础
### Vue概述
Vue：渐进式JavaScript框架 
### Vue基本使用
Vue代码 --> Vue框架 --> 原生js代码
### Vue模版语法
模板 + 数据 --> 前端渲染 == 静态HTML内容
#### 指令
指令的本质是自定义属性，指令的格式：以`v-`开头(`v-cloak`)  
##### v-cloak
插值表达式存在的问题：‘闪动’，可使用`v-cloak`解决，原理：**先隐藏，替换好值之后再显示最终的值**。
```html
<!-- v-cloak指令的用法
1、提供样式
  [v-cloak]{
    display: none;
  }
2、在插值表达式所在的标签中添加v-cloak指令 -->
<style type="text/css">
[v-cloak]{
  display: none;
}
</style>

  <div id="app">
  <div v-cloak>{{msg}}</div>
</div>
```
##### 数据绑定指令
- `v-text`：填充纯文本
- `v-html`：存在安全问题，本网站内部数据可以使用，来自第三方的数据不可以用
- `v-pre`：填充原始信息(跳过编译部分)

```html
<div>{{msg}}</div>
<div v-text='msg'></div>
<div v-html='msg1'></div>
<div v-pre>{{msg}}</div>
```
##### 数据响应式
数据响应式：数据的变化导致页面内容的变化。  
  
数据绑定：将数据填充到标签中，`v-once`：只编译一次，显示内容不再具有响应式功能。  
```html
<div>{{msg}}</div>
<div v-once>{{info}}</div>
```
#### 双向数据绑定指令
`v-model`指令用法：`<input type="text" v-model="uname" />`
```html
<div>
  <input type="text" v-model='msg'>
</div>
```
##### MVVM思想
- M：model
- V：view
- VM：View-Model

#### 事件绑定
`v-on`指令用法：`<input type=‘button' v-on:click='num++'/>`  
`v-on`简写用法：`<input type=‘button' @click='num++'/>`  

```html
<button v-on:click='num++'>点击</button>
<button @click='num++'>点击1</button>
```
##### 事件函数的调用方式
直接绑定属性名称：`<button v-on:click='say'>Hello</button>`  
调用函数：`<button v-on:click='say()'>Say hi</button>`  
```html
<button @click='handle'>点击2</button>
<button @click='handle()'>点击3</button>

<script type="text/javascript">
  var vm = new Vue({
      el: '#app',
      data: {
          num: 0
      }, // 注意点： 这里不要忘记加逗号 
      // methods 中主要是定义一些函数
      methods: {
          handle: function() {
              // 这里的this是Vue的实例对象+
              console.log(this === vm)
                  //  在函数中想要使用data里面的数据 一定要加this 
              this.num++;
          }
      }
  });
</script>
```
##### 事件函数参数传递
普通参数和事件对象：`<button v-on:click='say("hi",$event)'>Say hi</button>`
```html
<div id="app">
    <div>{{num}}</div>
    <div>
        <!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 -->
        <button v-on:click='handle1'>点击1</button>
        <!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，
              并且事件对象的名称必须是$event 
        -->
        <button v-on:click='handle2(123, 456, $event)'>点击2</button>
    </div>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
    var vm = new Vue({
        el: '#app',
        data: {
            num: 0
        },
        methods: {
            handle1: function(event) {
                console.log(event.target.innerHTML) // 点击1
            },
            handle2: function(p, p1, event) {
                console.log(p, p1)                  // 123 456
                console.log(event.target.innerHTML) // 点击2
                this.num++;
            }
        }
    });
</script>
```
##### 事件修饰符
- `.stop`阻止冒泡：`<a v-on:click.stop="handle">跳转</a>`
- `.prevent`阻止默认行为：`<a v-on:click.prevent="handle">跳转</a>`

```html
<div id="app">
  <div>{{num}}</div>
  <div v-on:click='handle0'>
    <button v-on:click.stop='handle1'>点击1</button>
  </div>
  <div>
    <a href="http://www.baidu.com" v-on:click.prevent='handle2'>百度</a>
  </div>
</div>
```
##### 按钮修饰符
- `.enter`回车键：`<input v-on:keyup.enter='submit'>`
- `.delete`删除键：`<input v-on:keyup.delete='handle'>` 

```html
<div id="app">
  <form action="">
    <div>
      用户名：
      <input type="text" v-on:keyup.delete='clearContent' v-model='uname'>
    </div>
    <div>
      密码：
      <input type="text" v-on:keyup.f1='handleSubmit' v-model='pwd'>
    </div>
    <div>
      <input type="button" v-on:click='handleSubmit' value="提交">
    </div>
  </form>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      uname: '',
      pwd: '',
      age: 0
    },
    methods: {
      clearContent:function(){
        // 按delete键的时候，清空用户名
        this.uname = '';
      },
      handleSubmit: function(){
        console.log(this.uname,this.pwd)
      }
    }
  });
</script>
```
##### 自定义按键修饰符
全局`config.keyCodes`对象，`Vue.config.keyCodes.f1 = 112`

```html
<div id="app">
  <input type="text" v-on:keyup.aaa='handle' v-model='info'>
</div>
<script type="text/javascript">
  /*
    规则：自定义按键修饰符名字是自定义的，但是对应的值必须是按键对应event.keyCode值
  */
  Vue.config.keyCodes.aaa = 65 // 必须按keyCode为65的键， aaa可以随意设置
  var vm = new Vue({
    el: '#app',
    data: {
      info: ''
    },
    methods: {
      handle: function(event){
        console.log(event.keyCode)
      }
    }
  });
</script>
```
#### 属性绑定
`v-bind`指令用法：`<a v-bind:href='url'>跳转</a>`  
缩写：`<a :href='url'>跳转</a>`  
```html
<div id="app">
  <a v-bind:href="url">百度</a>
  <a :href="url">百度1</a>
  <button v-on:click='handle'>切换</button>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      url: 'http://www.baidu.com'
    },
    methods: {
      handle: function(){
        // 修改URL地址
        this.url = 'https://pengpeng-qi.github.io/';
      }
    }
  });
</script>
```
##### v-model的底层实现原理分析
`<input v-bind:value="msg" v-on:input="msg=$event.target.value">`
```html
<div id="app">
  <div>{{msg}}</div>
  // 三种方式同效
  <input type="text" v-bind:value="msg" v-on:input='handle'>
  <input type="text" v-bind:value="msg" v-on:input='msg=$event.target.value'>
  <input type="text" v-model='msg'>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      msg: 'hello'
    },
    methods: {
      handle: function(event){
        // 使用输入域中的最新的数据覆盖原来的数据
        this.msg = event.target.value;
      }
    }
  });
</script>
```
#### 样式绑定
class样式处理：
- 对象语法：`<div v-bind:class="{active: isActive}"></div>`
- 数组语法：`<div v-bind:class="[activeClass, errorClass]"></div>`

对象绑定：
```html
<!-- 对象语法： -->
<!-- active、error css写在style里面 -->
<div id="app">
  <div v-bind:class="{active: isActive,error: isError}">
    测试样式
  </div>
  <button v-on:click='handle'>切换</button>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      isActive: true,
      isError: true
    },
    methods: {
      handle: function(){
        // 控制isActive的值在true和false之间进行切换
        this.isActive = !this.isActive;
        this.isError = !this.isError;
      }
    }
  });
</script>
```
数组绑定：
```html
<!-- 数组语法 -->
<!-- active、error css写在style里面 -->
<div id="app">
  <div v-bind:class='[activeClass, errorClass]'>测试样式</div>
  <button v-on:click='handle'>切换</button>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      activeClass: 'active',
      errorClass: 'error'
    },
    methods: {
      handle: function(){
        this.activeClass = '';
        this.errorClass = '';
      }
    }
  });
</script>
```
对象与数组绑定的注意事项：
```html
<div id="app">
  <div v-bind:class='[activeClass, errorClass, {test: isTest}]'>对象与数组结合</div>
  <div v-bind:class='arrClasses'>数组形式简化</div>
  <div v-bind:class='objClasses'>对象形式简化</div>
  <div class="base" v-bind:class='objClasses'>多个css</div>

  <button v-on:click='handle'>切换</button>
</div>
<script type="text/javascript">
  /*
    1、对象绑定和数组绑定可以结合使用
    2、class绑定的值可以简化操作
    3、默认的class会保留
  */
  var vm = new Vue({
    el: '#app',
    data: {
      activeClass: 'active',
      errorClass: 'error',
      isTest: true,
      arrClasses: ['active','error'],
      objClasses: {
        active: true,
        error: true
      }
    },
    methods: {
      handle: function(){
        // this.isTest = false;
        this.objClasses.error = false;
      }
    }
  });
</script>
```
style样式处理：
- 对象语法：`<div v-bind:style="{color: activeColor, fontSize: fontSize}"></div>`
- 数组语法：`<div v-bind:style="[baseStyle, overridingStyles]"></div>`

```html
<div id="app">
  <div v-bind:style='{border: borderStyle, width: widthStyle, height: heightStyle}'>对象样式</div>
  <div v-bind:style='objStyles'>简化形式</div>
  <div v-bind:style='[objStyles, overrideStyles]'>第二个style相对于第一个style，有的属性会覆盖，没有的话加上来</div>
  <button v-on:click='handle'>切换</button>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      borderStyle: '1px solid blue',
      widthStyle: '100px',
      heightStyle: '200px',
      objStyles: {
        border: '1px solid green',
        width: '200px',
        height: '100px'
      },
      overrideStyles: {
        border: '5px solid orange',
        backgroundColor: 'blue'
      }
    },
    methods: {
      handle: function(){
        this.heightStyle = '100px';
        this.objStyles.width = '100px';
      }
    }
  });
</script>
```
#### 分支循环结构
**分支结构**：
- 1、`v-if`
- 2、`v-else`
- 3、`v-else-if`
- 4、`v-show`

```html
<div id="app">
  <div v-if='score>=90'>优秀</div>                <!-- 不显示 -->
  <div v-else-if='score<90&&score>=80'>良好</div> <!-- 不显示 -->
  <div v-else-if='score<80&&score>60'>一般</div>  <!-- 不显示 -->
  <div v-else>比较差</div>
  <div v-show='flag'>测试v-show</div>             <!-- 不显示 -->
  <button v-on:click='handle'>点击</button>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  /*
    v-show的原理：控制元素样式是否显示 display:none
  */
  var vm = new Vue({
    el: '#app',
    data: {
      score: 10,
      flag: false
    },
    methods: {
      handle: function(){
        this.flag = !this.flag;
      }
    }
  });
</script>
```
`v-if`与`v-show`的区别：
- `v-if`控制元素**是否渲染到页面**、实质是控制DOM元素
- `v-show`控制元素**是否显示**(已经渲染到了页面)、适合频繁切换显示模式

**循环结构**：
- 1、`v-for`：遍历数组
  - `<li v-for='item in list'>{{item}}</li>`
  - `<li v-for='(item,index) in list'>{{item}} + '---' +{{index}}</li>`
- 2、key的作用：帮助Vue区分不同的元素，从而提高性能
  - `<li :key='item.id' v-for='(item, index) in list'>{{item}} + --- + {{index}}</li>`
- 3、遍历对象
  - `<div v-for='(value, key, index) in object'></div>`

```html
  <div id="app">
    <div>水果列表</div>
    <ul>
      <!-- 简单数组 -->
      <li v-for='item in fruits'>{{item}}</li>
      <li v-for='(item, index) in fruits'>{{item + '---' + index}}</li>

      <!-- 数组中有对象 -->
      <!-- 如果item没有id，可以使用index -->
      <li :key='item.id' v-for='(item, index) in myFruits'>
        <span>{{item.ename}}</span>   <!-- item是数组中的每一项 -->
        <span>{{item.cname}}</span>
      </li>

    </ul>
  </div>
  <script type="text/javascript">
    var vm = new Vue({
      el: '#app',
      data: {
        fruits: ['apple', 'orange', 'banana'],
        myFruits: [{
          id: 1,
          ename: 'apple',
          cname: '苹果'
        },{
          id: 2,
          ename: 'orange',
          cname: '橘子'
        },{
          id: 3,
          ename: 'banana',
          cname: '香蕉'
        }]
      }
    });
  </script>
```
遍历对象：
```html
<!-- v-if v-for结合使用 -->
<div id="app">
  <div v-if='v==13' v-for='(v,k,i) in obj'>{{v + '---' + k + '---' + i}}</div>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      obj: {
        uname: 'zhangsan',
        age: 13,
        gender: 'female'
      }
    }
  });
</script>
```
### Vue常用特性
#### 表单操作
- input
- textarea
- select
- radio
- checkbox

```html
<div id="app">
  <form action="http://itcast.cn">
    <div>
      <span>姓名：</span>
      <span>
        <input type="text" v-model='uname'>
      </span>
    </div>
    <div>
      <span>性别：</span>
      <span>
        <input type="radio" id="male" value="1" v-model='gender'>
        <label for="male">男</label>
        <input type="radio" id="female" value="2" v-model='gender'>
        <label for="female">女</label>
      </span>
    </div>
    <div>
      <span>爱好：</span>
      <input type="checkbox" id="ball" value="1" v-model='hobby'>
      <label for="ball">篮球</label>
      <input type="checkbox" id="sing" value="2" v-model='hobby'>
      <label for="sing">唱歌</label>
      <input type="checkbox" id="code" value="3" v-model='hobby'>
      <label for="code">写代码</label>
    </div>
    <div>
      <span>职业：</span>
      <select v-model='occupation' multiple>
        <option value="0">请选择职业...</option>
        <option value="1">教师</option>
        <option value="2">软件工程师</option>
        <option value="3">律师</option>
      </select>
    </div>
    <div>
      <span>个人简介：</span>
      <textarea v-model='desc'></textarea>
    </div>
    <div>
      <input type="submit" value="提交" @click.prevent='handle'>
    </div>
  </form>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      uname: 'lisi',          // 默认值lisi
      gender: 2,              // 默认第二个被选中
      hobby: ['2','3'],       // 默认第二、三个被选中
      // occupation: 3        // 默认选择第三个
      occupation: ['2','3'],  // 默认第二、三个被选中
      desc: 'nihao'           // 默认值nihao
    },
    methods: {
      handle: function(){
        // console.log(this.uname)
        // console.log(this.gender)
        // console.log(this.hobby.toString())
        // console.log(this.occupation)
        console.log(this.desc)
      }
    }
  });
</script>
```
可通过[这个](/demo/Vue/表单基本操作.html)查看  
表单域修饰符：
- number：转化为数值
- trim：去掉开始和结尾的空格
- lazy：将input事件(表单内数值发送改变就会触发)切换为change(失去焦点才会发送触发)事件

`<input v-model.number="age" type="number">`
#### 自定义指令
**自定义指令的语法规则**(获取元素焦点)：
```js
Vue.directive('focus' {
  inserted: function(el) {
  // 获取元素的焦点
    el.focus();
  }
})
```
**自定义指令用法**：
```js
<input type="text" v-focus>
```
**带参数的自定义指令**：
```html
<div id="app">
  <input type="text" v-color='msg'>
</div>
<script type="text/javascript">
  Vue.directive('color', {
    bind: function(el, binding){
      // 根据指令的参数设置背景色
      el.style.backgroundColor = binding.value.color;
    }
  });
  var vm = new Vue({
    el: '#app',
    data: {
      msg: {
        color: 'blue'
      }
    },
  });
</script>
```
**局部指令**：
```js
var vm = new Vue({
  el: '#app',
  data: {
    msg: {
      color: 'red'
    }
  },
  directives: {
    color: {
      bind: function(el, binding){
        el.style.backgroundColor = binding.value.color;
      }
    },
    focus: {
      inserted: function(el) {
        el.focus();
      }
    }
  }
});
```
#### 计算属性
使用计算属性使模版内容更加简洁
```html
<div id="app">
  <div>{{msg}}</div>
  <!-- 第一种方式 -->
  <div>{{msg.split('').reverse().join('')}}</div>
  <!-- 第二种方式：使模版更加简洁 -->
  <div>{{reverseString}}</div>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      msg: 'Nihao'
    },
    computed: {
      reverseString: function(){
        return this.msg.split('').reverse().join('');
      }
    }
  });
```
**计算属性和方法的区别**：
- 计算属性是基于它们的依赖(例如data里面的数据,如果数据发生变化的话需要重新计算)进行缓存的
- 方法不存在缓存

```html
<div id="app">
  <div>{{reverseString}}</div>
  <div>{{reverseString}}</div>
  <div>{{reverseMessage()}}</div>
  <div>{{reverseMessage()}}</div>
</div>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      msg: 'Nihao',
      num: 100
    },
    methods: {
      reverseMessage: function(){
        console.log('methods')
        return this.msg.split('').reverse().join('');
      }
    },
    computed: {
      reverseString: function(){
        console.log('computed')
        // return this.msg.split('').reverse().join('');
        var total = 0;
        for(var i=0;i<=this.num;i++){
          total += i;
        }
        return total;
      }
    }
  });
```
> 缓存之后第二次调用就不用再进行计算，而方法调用一次则执行一次，计算属性可提高性能。

#### 侦听器
数据一旦发生变化就通知侦听器所绑定方法  
  
```js
watch: {
  firstName: function(val){
  // val表示变化之后的值
  this.fullName = val + this.lastName; 
  },
  lastName: function(val) {
  this.fullName = this.firstName + val;
  } 
}
```
具体案例可见[验证用户名是否可用](/demo/Vue/验证用户名是否可用.html)
#### 过滤器
格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等.  
  
自定义过滤器：
```js
Vue.filter(‘过滤器名称’, function(value){ 
  // 过滤器业务逻辑
})
```
```html
<div id="app">
  <input type="text" v-model='msg'>
  <div>{{msg | upper}}</div>
  <!-- 级联操作，先对upper过滤然后将结果进行lower过滤 -->
  <div>{{msg | upper | lower}}</div>
  <!-- 属性绑定 -->
  <div :abc='msg | upper'>测试数据</div>
</div>
<script type="text/javascript">
  /*
    过滤器
    1、可以用与插值表达式和属性绑定
    2、支持级联操作
  */
  // Vue.filter('upper', function(val) {
  //   return val.charAt(0).toUpperCase() + val.slice(1);
  // });
  Vue.filter('lower', function(val) {
    return val.charAt(0).toLowerCase() + val.slice(1);
  });
  var vm = new Vue({
    el: '#app',
    data: {
      msg: ''
    },
    filters: {
      upper: function(val) {
        return val.charAt(0).toUpperCase() + val.slice(1);
      }
    }
  });
</script>
```
#### 生命周期
主要阶段：
- 1、挂载
  - `beforeCreate`：在实例化初始之后，数据观测和事件配置之前被调用
  - `created`：实例创建完成之后被立即调用
  - `beforeMount`：挂载开始之前被调用
  - `mounted`：el被新创建的`vm.$el`替换，并挂载到实例上去之后调用该钩子
- 2、更新
  - `beforeUpdate`：数据更新时调用，发生在虚拟DOM打补丁之前
  - `updated`：数据更换导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子
- 3、销毁
  - `beforeDestory`：实例销毁之前调用
  - `destoryed`：实例销毁后调用

### 综合案例
#### 变异方法
会修改原始数据
- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

#### 替换数组
生成新数组
- `filter()`
- `concat()`
- `slice()`

#### 修改响应式数据
- `Vue.set(vm.items, indexOfItem, newValue)`
- `vm.$set(vm.items, indexOfItem, newValue)`
  - 1 参数一表示要处理的数组名称 
  - 2 参数二表示要处理的数组的索引 
  - 3 参数三表示要处理的数组的值
 
```html
<div id="app">
  <ul>
    <li v-for='item in list'>{{item}}</li>
  </ul>
  <div>
    <div>{{info.name}}</div>
    <div>{{info.age}}</div>
    <div>{{info.gender}}</div>
  </div>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      list: ['apple', 'orange', 'banana'],
      info: {
        name: 'lisi',
        age: 12
      }
    },
  });
  // 操作数组
  // vm.list[1] = 'lemon'; // 值被修改，但是不会响应式显示在页面上
  vm.$set(vm.list, 1, 'lemon');  // 响应式显示在页面上

  // 操作对象
  // vm.info.gender = 'male'; // 值被修改，但是不会响应式显示在页面上
  vm.$set(vm.info, 'gender', 'female'); 
  </script>
```
## Vue组件化开发
### 组件注册
#### 全局组件注册语法
```js
Vue.component(组件名称, {
  data: 组件数据,
  template: 组件模版内容
})
```
注册一个名为`button-counter`的新组件
```js
// 组件命名方式可使用短横线方式、或者驼峰方式
// 多个组件可以互相使用，但是在根组件中只能使用短横线方式
Vue.component('button-counter', {
  // 组件 data必须是一个函数
  data: function() {
    return {
      count: 0
    }
  },
  // 组件模块内容必须是单个根元素，也可以是模版字符串
  template: '<div><button v-on:click="count++">点击了{{ count++ }}次</button><button>按钮</button></div>'

  // 组件模版内容也可以是模版字符串
  // template: 
  // `<div>
  //   <button v-on:click="count++">点击了{{ count++ }}次</button>
  //   <button>按钮</button>
  // </div>`,

})
```
#### 局部组件注册
```js
var ComponentA = { /* ... */ } 
var ComponentB = { /* ... */ } 
var ComponentC = { /* ... */ } 
new Vue({
  el: '#app' 
  components: {
  'component-a': ComponentA, 
  'component-b': ComponentB, 
  'component-c': ComponentC,
  } 
})
```
局部组件只能在注册他的父组件中使用
```html
<div id="app">
  <hello-world></hello-world>
  <hello-tom></hello-tom>
  <hello-jerry></hello-jerry>
  <test-com></test-com>
</div>
<script type="text/javascript">
  /*
    局部组件注册
    局部组件只能在注册他的父组件中使用
  */
  Vue.component('test-com',{
    template: '<div>Test<hello-world></hello-world></div>' 
    // 不会显示hello-world组件的信息
  });
  var HelloWorld = {
    data: function(){
      return {
        msg: 'HelloWorld'
      }
    },
    template: '<div>{{msg}}</div>'
  };
  var HelloTom = {
    data: function(){
      return {
        msg: 'HelloTom'
      }
    },
    template: '<div>{{msg}}</div>'
  };
  var HelloJerry = {
    data: function(){
      return {
        msg: 'HelloJerry'
      }
    },
    template: '<div>{{msg}}</div>'
  };
  var vm = new Vue({
    el: '#app',
    data: {
      
    },
    components: {
      'hello-world': HelloWorld,
      'hello-tom': HelloTom,
      'hello-jerry': HelloJerry
    }
  });
</script>
```
### 组件间数据交互
#### 父组件向子组件传值
组件内部通过`props`接收传递过来的值
```js
Vue.component('menu-item', {
  props: ['title'],
  template: '<div>{{ title }}</div>'
})
```
父组件通过属性将值传递给子组件：
```html
<!-- 静态的方式 -->
<menu-item title="来自父组件的数据"></menu-item> 

<!-- 动态的方式，进行属性绑定,父组件 -->
<menu-item :title="title"></menu-item>
```
父组件向子组件传值-基本使用
```html
<div id="app">
  <div>{{pmsg}}</div>
  <menu-item title='来自父组件的值'></menu-item>
  <!-- 动态title + 静态content -->
  <menu-item :title='ptitle' content='hello'></menu-item>
</div>
<script type="text/javascript">
    // 子组件
  Vue.component('menu-item', {
    props: ['title', 'content'],
    data: function() {
      return {
        msg: '子组件本身的数据'
      }
    },
    template: '<div>{{msg + "----" + title + "-----" + content}}</div>'
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      ptitle: '动态绑定属性'
    }
  });
</script>
```
props属性名规则：
- 1、在props中使用驼峰形式，模版中需要使用短横线的形式
- 2、字符串形式的模版中没有这个限制

```html
<div id="app">
  <div>{{pmsg}}</div>
  <!-- :menu-title 在模版中需要使用短横线的形式 -->
  <menu-item :menu-title='ptitle'></menu-item>
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  Vue.component('third-com', {
    props: ['testTile'],
    template: '<div>{{testTile}}</div>'
  });
  Vue.component('menu-item', {
    // 在props中使用驼峰形式
    props: ['menuTitle'],
    // testTile 在字符串里面可以使用驼峰的形式
    template: '<div>{{menuTitle}}<third-com testTile="hello"></third-com></div>'
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      ptitle: '动态绑定属性'
    }
  });
</script>
```
**props属性值类型**：
- 字符串string
- 数值Number
- 布尔值Boolean
- 数组Array
- 对象Object

```html
<div id="app">
  <div>{{pmsg}}</div>
  <!-- number、boolean加了：进行绑定得到的是对应的类型，如果没加则为字符串类型  -->
  <menu-item :pstr='pstr' :pnum='12' pboo='true' :parr='parr' :pobj='pobj'></menu-item>
</div>
<script type="text/javascript">
  Vue.component('menu-item', {
    props: ['pstr','pnum','pboo','parr','pobj'],
    template: `
      <div>
        <div>{{pstr}}</div>
        <div>{{12 + pnum}}</div>
        <div>{{typeof pboo}}</div>  
        <ul>
          <li :key='index' v-for='(item,index) in parr'>{{item}}</li>
        </ul>
          <span>{{pobj.name}}</span>
          <span>{{pobj.age}}</span>
        </div>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      pstr: 'hello',
      parr: ['apple','orange','banana'],
      pobj: {
        name: 'lisi',
        age: 12
      }
    }
  });
</script>
```
#### 子组件向父组件传值
子组件通过自定义事件向父组件传递信息：
```html
<button v-on:click='$emit("enlarge-text") '>扩大字体</button>
```
父组件监听子组件的事件：
```html
<menu-item v-on:enlarge-text='fontSize += 0.1'></menu-item>
```
```html
<div id="app">
  <div :style='{fontSize: fontSize + "px"}'>{{pmsg}}</div>
  <!-- 父组件 -->
  <menu-item @enlarge-text='handle'></menu-item>
</div>
<script type="text/javascript">   
  // 子组件 
  Vue.component('menu-item', {
    template: `
      <div>
        <button @click='$emit("enlarge-text")'>扩大父组件中字体大小</button>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      fontSize: 10
    },
    methods: {
      handle: function(){
        // 扩大字体大小
        this.fontSize += 5;
      }
    }
  });
</script>
```
子组件通过自定义事件向父组件传递信息：
```html
<button v-on:click='$emit("enlarge-text", 0.1) '>扩大字体</button>
```
父组件监听子组件的事件：
```html
<menu-item v-on:enlarge-text='fontSize += $event'></menu-item>
```
```html
<div id="app">
  <div :style='{fontSize: fontSize + "px"}'>{{pmsg}}</div>
  <!-- 父组件 -->
  <menu-item @enlarge-text='handle($event)'></menu-item>
</div>
<script type="text/javascript">   
  // 子组件 
  Vue.component('menu-item', {
    template: `
      <div>
        <button @click='$emit("enlarge-text", 5)'>扩大父组件中字体大小</button>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      pmsg: '父组件中内容',
      fontSize: 10
    },
    methods: {
      handle: function(val){
        // 扩大字体大小
        this.fontSize += val;
      }
    }
  });
</script>
```
#### 非父组件间传值
单独的事件中心管理组件间的通信：
```js
var eventHub = new Vue()
```
监听事件与销毁事件：
```js
eventHub.$on('add-todo', addTodo)
eventHub.$off('add-todo')
```
触发事件：
```js
eventHub.$emit('add-todo', id)
```
```html
  <div id="app">
    <div>父组件</div>
    <div>
      <button @click='handle'>销毁事件</button>
    </div>
    <test-tom></test-tom>
    <test-jerry></test-jerry>
  </div>
  <script type="text/javascript">
    /*
      兄弟组件之间数据传递
    */
    // 提供事件中心
    var hub = new Vue();

    Vue.component('test-tom', {
      data: function(){
        return {
          num: 0
        }
      },
      template: `
        <div>
          <div>TOM:{{num}}</div>
          <div>
            <button @click='handle'>点击</button>
          </div>
        </div>
      `,
      methods: {
        handle: function(){
          hub.$emit('jerry-event', 2);
        }
      },
      mounted: function() {
        // 监听事件
        hub.$on('tom-event', (val) => {
          this.num += val;
        });
      }
    });
    Vue.component('test-jerry', {
      data: function(){
        return {
          num: 0
        }
      },
      template: `
        <div>
          <div>JERRY:{{num}}</div>
          <div>
            <button @click='handle'>点击</button>
          </div>
        </div>
      `,
      methods: {
        handle: function(){
          // 触发兄弟组件的事件
          hub.$emit('tom-event', 1);
        }
      },
      mounted: function() {
        // 监听事件
        hub.$on('jerry-event', (val) => {
          this.num += val;
        });
      }
    });
    var vm = new Vue({
      el: '#app',
      data: {
        
      },
      methods: {
        handle: function(){
          hub.$off('tom-event');
          hub.$off('jerry-event');
        }
      }
    });
  </script>
```
### 组件插槽
父组件向子组件传递内容：  
1、插槽位置：  
```js
Vue.component('alert-box', { 
  template: `
    <div class="demo-alert-box"> 
    <strong>Error!</strong> 
    <slot></slot>
    </div> 
    `
})
```
2、插槽内容：
```html
<alert-box>Something bad happened.</alert-box>
```
```html
<div id="app">
  <alert-box>有bug发生</alert-box>   <!-- ERROR:有bug发生 -->
  <alert-box>有一个警告</alert-box>   <!-- ERROR:有bug发生 -->
  <alert-box></alert-box>           <!-- ERROR:默认内容 -->
</div>
<script type="text/javascript" src="js/vue.js"></script>
<script type="text/javascript">
  /*
    组件插槽：父组件向子组件传递内容
  */
  Vue.component('alert-box', {
    template: `
      <div>
        <strong>ERROR:</strong>
        <slot>默认内容</slot>
      </div>
    `
  });
```
#### 具名插槽
插槽的定义：
```html
<div class="container">
  <header>
    <slot name="header"></slot> 
  </header>
  <main>
    <slot></slot> 
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```
插槽内容：
```html
<base-layout>
  <h1 slot="header">标题内容</h1>
  <p>主要内容1</p> 
  <p>主要内容2</p>
  <p slot="footer">底部内容</p> 
</base-layout>
```
```html
<div id="app">
  <base-layout>
    <!-- header区域 -->
    <p slot='header'>标题信息</p>
    <!-- main区域 -->
    <p>主要内容1</p>
    <p>主要内容2</p>
    <!-- footer区域 -->
    <p slot='footer'>底部信息信息</p>
  </base-layout>

  <base-layout>
    <!-- header区域 -->
    <template slot='header'>
      <p>标题信息1</p>
      <p>标题信息2</p>
    </template>
    <!-- main区域 -->
    <p>主要内容1</p>
    <p>主要内容2</p>
    <!-- footer区域 -->
    <template slot='footer'>
      <p>底部信息信息1</p>
      <p>底部信息信息2</p>
    </template>
  </base-layout>
</div>
<script type="text/javascript">
  /*
    具名插槽
  */
  Vue.component('base-layout', {
    template: `
      <div>
        <header>
          <slot name='header'></slot>
        </header>
        <main>
          <slot></slot>
        </main>
        <footer>
          <slot name='footer'></slot>
        </footer>
      </div>
    `
  });
```
#### 作用域插槽
父组件对子组件的内容进行加工处理  
  
插槽定义：
```html
<ul>
  <li v-for= "item in list" v-bind:key= "item.id" >
    <!-- 提供一个属性，名字可自定义，值为操作的数据 -->
    <slot v-bind:item="item"> 
      {{item.name}}
     </slot>
  </li>
</ul>
```
插槽内容：
```html
<fruit-list v-bind:list= "list"> 
  <!-- slot-scope得到子组件传过来的数据 -->
  <template slot-scope="slotProps">
    <!-- item是在上面 v-bind绑定的名字 -->
    <strong v-if="slotProps.item.current"> 
      {{ slotProps.item.text }}
    </strong> 
  </template> 
</fruit-list>
```
```html
<div id="app">
  <fruit-list :list='list'>
    <template slot-scope='slotProps'>
      <strong v-if='slotProps.info.id==3' class="current">{{slotProps.info.name}}</strong>
      <span v-else>{{slotProps.info.name}}</span>
    </template>
  </fruit-list>
</div>
<script type="text/javascript">
  Vue.component('fruit-list', {
    props: ['list'],
    template: `
      <div>
        <li :key='item.id' v-for='item in list'>
          <slot :info='item'>{{item.name}}</slot>
        </li>
      </div>
    `
  });
  var vm = new Vue({
    el: '#app',
    data: {
      list: [{
        id: 1,
        name: 'apple'
      },{
        id: 2,
        name: 'orange'
      },{
        id: 3,
        name: 'banana'
      }]
    }
  });
</script>
```