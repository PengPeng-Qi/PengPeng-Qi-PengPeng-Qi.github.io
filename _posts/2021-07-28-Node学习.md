---
layout:     post
title:      Node.js 基础部分
date:       2021-07-28
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - Node.js
    - Npm
    - Notes
---
## Node.js与内置模块
### Node.js
**Node.js**是一个基于Chrome V8引擎的JavaScript的**后端运行环境**。  
**浏览器**是JavaScript的**前端运行环境**。  

基于`Express`可以快速构建Web应用、基于`Electron`可以跨平台构建桌面应用、基于`restify`可以快速构建API接口项目  

**Node.js**环境执行JS代码：打开终端、输入node要执行的js文件路径  
### fs系统模块
- `fs.readFile()`方法，用来**读取指定文件**中的内容
- `fs.writeFile()`方法，用来向指定的文件中**写入内容**、只能用来创建文件，而不能用来创建路径

如果要在JS代码中使用fs模块，需要先导入他`const fs = require('fs')`
  
使用`fs.readFile()`方法，可以**读取指定文件中的内容**，语法格式如下：`fs.readFile(path[, option], callback)`
  
- `path`必选参数，字符串，表示文件的路径
- `option`，可选参数，表示以什么**编码格式**来读取文件
- `callback`，必选参数，文件读取完成后，可以通过回调函数拿到读取的结果
  
```js
const fs = require('fs');

fs.readFile('../txt.txt', 'utf8', function(err, res){
  if (err) {
    return console.log('读取信息失败', err);
  };
  console.log(res);
})
```
`fs.writeFile()`方法，用来向指定的文件中写入内容
  - `file`：**必选**参数，指定一个**文件路径的字符串**，表示文件的存储路径
  - `data`：**必选**参数，表示要写入的内容
  - `option`：可选参数，表示以什么格式写入文件内容，默认值是utf8
  - `callback`：**必选**参数，文件写入完成后的回调函数
```js
fs.writeFile(file, data[, option], callback)
```
```js
const fs = require('fs');

fs.writeFile('.../我是用fs写的文件.txt', 'Hello, World!', 'utf8', function(err){
  err ? console.log('文件写入失败: ', err) : console.log('文件写入成功');
})
```
> 当我们在terminal中使用node允许js是，如果没有在js所在文件夹，使用上面的路径方式容易引起路径出错问题

我们常使用`__dirname` 可显示当前文件存放的位置,且不需要导入模块使用，即可显示文件所在所在位置，常用于文件拼接时
```js
console.log(__dirname); // /Users/pengqi/Documents/GitHub/PengPeng-Qi.github.io/demo/Node/FS
```

### path模块
path模块是官方提供的、用来**处理路径**的模块
- `path.join([...paths])`：用来将**多个路径片段拼接成一个完整的路径字符串**
- `path.basename()`：用来从路径字符串中，将**文件名解析**出来
- `path.extname()`：用来获取路径中的拓展名部分

#### path.join()
```js
const path = require('path');

const pathStr = path.join('/a', '/b/c');
console.log(pathStr); // /a/b/c

const pathStr1 = path.join('/a', '/b/c', '../'); // ../等同于回退一个文件夹
console.log(pathStr1); // /a/b/

const pathStr2 = path.join('/a', '/b/c', './d'); // ./d 等同于/d
console.log(pathStr2); // /a/b/c/d

const pathStr2 = path.join(__dirname, './files/text.txt'); 
const pathStr2 = path.join(__dirname, '/files/text.txt'); //使用path.join上面两种方式结果一致

const pathStr2 = (__dirname + './files/text.txt');
const pathStr2 = (__dirname + '/files/text.txt');  // 使用 + 上面两种方式结果不一致

// 凡事涉及到路径问题，都要使用path.join()方法进行处理，不要使用 + 进行字符串拼接
```
#### path.basename() && path.extname()
`path.basename(path[, ext])`：用来从路径字符串中，将**文件名解析**出来(ext表示文件拓展名)  
`path.extname(path)`：用来获取路径中的拓展名部分
```js
// path.join()将多个路径结合
const fpath = path.join(__dirname, '/a/b/c/index.html');

// path.basename将文件名解析出来
const fullName = path.basename(fpath);  // index.html

// path.extname将拓展名解析出来
const ftext = path.extname(fpath);      // .html
```
### HTTP模块
http 模块提供的 `http.createServer()`方法，能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。  
  
可以使用`ping www.baidu.com`命令，查看到百度服务器的 IP 地址。  
  
域名服务器(DNS): 提供**域名**与**ip地址**之间互相转换的服务器。  
  
#### 创建最基本的web服务器
- 1、导入http模版
- 2、创建web服务器实例
- 3、为服务器实例绑定`request`事件，**监听客户端的请求**
- 4、启动服务器

```js
// 导入http模块
const http = require('http')

// 创建web服务器实例
const server = http.createServer()

// 为服务器实例绑定request事件,即可监听客户端发送过来的网络请求
server.on('request', (req, res) => {
  // 只要有客户端来请求我们自己的服务器，就会触发request事件，从而调用这个事件处理函数
  // req 是请求对象，包含了与客户端相关的属性和数据
  // req.url 是客户端请求的URL 地址
  // req.method 是客户端的method 请求类型
  const str = `你请求 url is ${req.url}, and request method is ${req.method}`
  console.log(str)

  // res 是响应对象，它包含了与服务器相关的数据和属性，例如：
  // 为了防止中文显示乱码的问题，需要设置响应头
  res.setHeader('Content-Type', 'text/html; charset=utf8')

  // res.end()方法向客户端发生知道内容，并结束这次请求的处理过程
  res.end(str);
})

// 调用server.listen(端口号, cd回调) 方法， 即可启动web 服务器
server.listen(80, () => {
console.log('http server running at http://127.0.0.1')
})
```
可通过不同的url 地址提供不同的html 内容
```js
const http = require('http')

const server = http.createServer()

server.on('request', function (req, res) {
  // 1、获取请求的地址
  const url = req.url 

  // 2、设置默认内容为404 ...
  let content = '<h1>404 Not Found!</h1>' 

  if (url === '/' || url === '/index.html') {
    // 3、用户请求的是首页
    content = '<h1>首页</h1>' 
  } else if (url === '/about.html') {
    // 4、用户请求的是关于页面
    content = '<h1>关于页面</h1>' 
  }

  // 5、设置响应头，防止中文乱码
  res.setHeader('Content-Type', 'text/html; charset=utf8') 
  // 6、把内容发生给客户端
  res.end(content) 
})

server.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```
## 模块化
### Node.js中模块化
Node.js中根据模块来源的不同，将模块分为三大类：
- 1、内置模块：fs、path、http
- 2、自定义模块：用户创建的.js文件
- 3、第三方模块

#### 加载模块
使用强大的`require()`方法，可以讲三类模块加入进行使用：
```js
// 加载内置fs 模块
const fs = require('fs');

// 加载用户自定义模块
const custom = require('./custom.js')

// 导入自定义模块
// 均能正常导入
const Hi = require('./被导入模块.js')
const Hi = require('./被导入模块')

// 此方式不能正常导入
// const Hi = require('被导入模块.js')
// const Hi = require('被导入模块')

/* 使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。
在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，
则 node 会把它当作内置模块或第三方模块进行加载。 */

// 加载第三方模块
const moment = require('moment')
```
#### Node.js的模块作用域
与函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在**当前模块内被访问**，这种模块级别的访问限制，叫做**模块作用域**。  
  
优点：阻止了全局变量污染的问题  
#### 向外共享模块作用域的成员
##### module对象
每个`.js`自定义模块都有一个module对象，他里面**存储了和当前模块有关的信息**。
```js
console.log(module);

Module {
  id: '.',
  path: '...',
  exports: {},    // 将模块内的成员共享出去，供外界使用
  filename: '...',
  loaded: false,
  children: [],
  paths: [
    ...
  ]
}
```
##### module.exports对象
在自定义模块中，可以使用 `module.exports`对象，将模块内的成员共享出去，供外界使用。外界用`require()`方法导入自定义模块时，得到的就是`module.exports` 所指向的对象, 默认等于空。  
  
使用`require()` 方法导入模块时，导入的结果，**永远以`module.exports`指向的对象为准**。  
```js
// 1、被导入模块
var Obj = {
  name: 'Nibai'
}

module.exports = {
  Obj
}

// 导入模块
const Hi = require('./被导入模块.js')
console.log(Hi); // { Obj: { name: 'Nibai' } }
console.log(Hi.Obj.name); // Nibai

// 2、被导入模块
function dataFormat(str){
  const min = new Date(str);

  // console.log(min); //2021-07-28T01:38:44.689Z

  const YY  = padZero(min.getFullYear());
  const MM = padZero(min.getMonth() + 1);
  const DD = padZero(min.getDate());

  const HH = padZero(min.getHours());
  const Min = padZero(min.getMinutes());
  const sec = padZero(min.getSeconds());

  console.log(`${YY}:${MM}:${DD} ${HH}:${Min}:${sec}`);
}
// 补零
function padZero(d){
  return d > 9 ? d : '0' + d;
}

module.exports = {
  dataFormat
}

// 导入模块
const dateFormat = require('./格式化时间')

const now = new Date();

dateFormat.dataFormat(now); // 2021:07:28 09:51:18
```
`exports`对象，为了简化向外共享成员的代码，Node提供了`exports`对象。默认情况下，`exports`和`module.exports`指向同一个对象。
```js
// 被导入模块也可以写成
console.log('你好')

// 正常
// module.exports = {
//   Obj
// }

// 简写
exports.Obj = {
  name: 'Nibai'
}
```
> 当`exports` 与`module.exports` 同时存在时，得到的永远是 `module.exports` 指向的对象, 简易不要同时使用两个

Node.js遵循了CommonJS的规范：
- 1、每个模块内部，`module` 变量代表当前模块。
- 2、`module` 变量是一个对象，它的 `exports`属性(即`module.exports`)是对外的接口。
- 3、加载某个模块，其实是加载该模块的`module.exports` 属性。`require()` 方法用于加载模块。

### npm与包
Node.js 中的**第三方模块又叫做包**。

初次装包完成后，在项目文件夹下多一个叫做`node_modules` 的文件夹和 `package-lock.json`的配置文件。  
  
1、`node_modules` 文件夹用来**存放所有已安装到项目中的包**。`require()`导入第三方包时，就是从这个目录中查找并加载包。  
2、`package-lock.json` 配置文件用来记录 `node_modules`目录下的**每一个包的下载信息**，例如包的名字、版本号、下载地址等。  

#### 快速创建package.json
在项目根目录中，创建一个叫做`package.json` 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除`node_modules`目录之后，在团队成员之间共享项目的源代码。  
今后在项目开发中，一定要把`node_modules`文件夹，添加到`.gitignore` 忽略文件中。
```js
// 在执行命令所处的目录中，快速创建package.json 文件
npm init -y
```
> 1 上述命令**只能在英文的目录下成功运行**!所以，项目文件夹的名称一定要使用英文命名，**不要使用中文，不能出现空格**。  
> 2 运行`npm install` 命令安装包的时候，npm 包管理工具会自动把**包的名称和版本号**，记录到`package.json` 中。
  
`package.json` 文件中，有一个`dependencies` 节点，专门用来记录您使用`npm install`命令安装了哪些包。  
#### 一次性安装所有包
当执行`npm install` 命令时，npm包管理工具会自动优先读取`package.json`中的`dependencies` 节点，读取到依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中。  
```js
npm install
```
#### 卸载包
可以允许`npm uninstall`命令，来卸载指定的包：  
```js
// 使用npm uninstall 具体的包
npm uninstall moment
```
> `npm uninstall` 命令执行成功后，会把卸载的包，自动从`package.json` 的 `dependencies`中移除掉。
 
#### devDependencies节点

如果某些包**只在项目开发阶段**会用到，在**项目上线之后不会用到**，则建议把这些包记录到`devDependencies`(开发依赖包) 节点中。  
  
与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 `dependencies`(核心依赖包)节点中。  
```js
// 安装指定的包，并记录到devDependencies 节点中
npm i 包名 -D

// 注意：上诉命令是简写形式，等价于下面的完整写法
npm install 包名 --save-dev
```
#### 切换npm的下包镜像源
下包的镜像源，指的就是下包的服务器地址。  
```js
// 查看当前的下包镜像源
npm config get registry

// 将下包的镜像源切换为淘宝镜像源
npm config set registry=https://registry.npm.taobao.org/

// 检查镜像源是否下载成功
npm config get registry
```
`nrm` 提供的终端命令，可以快速查看和切换下包的镜像源。
#### 全局包
在执行`npm install`命令时，如果提供了`-g` 参数，则会把包安装为**全局包**。只有工作性质的包，才会有安全全局的必要性，可以参考官方提供的使用说明。  
```js
npm i 包名 -g  // 全局安装
npm uninstall 包名 -g  // 全局卸载
```

