---
layout:     post
title:      LeetCode 刷题笔记
date:       2021-07-30
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - JavaScript
    - LeetCode
    - Notes
---
## 前言
本文会每日更新在[LeetCode](https://leetcode-cn.com/)刷题时存在的一些问题。
### 字符串篇
#### 题目1：最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。  
  
如果不存在公共前缀，返回空字符串 ""。  
```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```
```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function (strs) {
  if(strs.length === 0) return '';
  // 去第一个字符串为初始值
  let ans = strs[0];
  // 遍历数组
  for (let i = 1; i < strs.length; i++){
    // 方便后面裁截字符串
    let j = 0;
    // 遍历字符串
    for (; j < strs[i].length && j < ans.length; j++){
      // 当不匹配时退出循环，开始裁剪字符串
      if (ans[j] !== strs[i][j]){
        break;
      }
    }
    // 注意j 是截取的长度，又由于j在循环的最后一步加1，所以可以抵消字符串第一个数字为0的问题
    ans = ans.substr(0, j);
  }
  return ans;
};
```
#### 最长无重复字符子串
给定一个字符串 s ，请你找出其中不含有重复字符的**最长子串** 的长度。
```
示例 1:

输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。

请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```
```js
var lengthOfLongestSubstring = function (s) {
  if (s.length <= 1) {
    return s.length
  }

  let l = 0;   // 定义左指针
  let ans = 0; // 定义结果
  let map = new Map();  // 存放字符串和对应下标
  // r 表示右指针
  for (let r = 0; r < s.length; r++) {
    // 如果出现字符串重复，则把左指针移到重复字符的下一位，注意同时满足重复字符的索引大于左指针
    // 因为可能出现已经被移动过的指针再次弹回去
    /* abba 遍历a的时候再次移动到第一个a*/
    if (map.has(s[r]) && map.get(s[r]) >= l) {
      l = map.get(s[r]) + 1
    }
    // 计算结果
    ans = Math.max(ans, r - l + 1)
    map.set(s[r], r)
  }
  return ans;
};

console.log(lengthOfLongestSubstring("abba"));
```
#### 题目2：有效的括号
给定一个只包括 `'('，')'，'{'，'}'，'['，']'` 的字符串 `s` ，判断字符串是否有效。  
  
有效字符串需满足：  
- **左括号必须用相同类型的右括号闭合**。
- 左括号必须以**正确的顺序闭合**。

```
输入：s = "()[]{}"
输出：true

输入：s = "([)]"
输出：false

输入：s = "(]"
输出：false
```
**思路**：  
先将前面的入栈，如果后面的字符与入栈的最后一个字符相对应，则之前入栈的最后一个字符出栈。如果符合条件的话栈里应该为空，所以返回`!栈的长度`  
  
解法一：
```js
let isValid = function (s) {
  let stack = [],
    length = s.length;
  if (length % 2) return false;
  // 使用for of 遍历键值 如果是字符串：0对应的值1对应的值2对应的值...
  // 使用for in 遍历键名 如果是字符串：01234...
  for (let item of s) {
    // 采取入栈出栈的思路，如果正确入栈则必须出栈
    switch (item) {
      case "{":
      case "[":
      case "(":
        stack.push(item);
        break;
      case "}":
        if (stack.pop() !== "{") return false;
        break;
      case "]":
        if (stack.pop() !== "[") return false;
        break;
      case ")":
        if (stack.pop() !== "(") return false;
        break;
    }
  }
  // 如果存在多次入栈且无出栈((,则应该返回false
  return !stack.length;
};
console.log(isValid('(('));
```
解法二：
```js
var isValid = function (s) {
  s = s.split('');
  let sl = s.length;
  if (sl % 2) return false;
  let map = new Map([
    [')', '('],
    [']', '['],
    ['}', '{']
  ]);
  let stack = [];
  for (let i of s) {
    console.log(i)
    if (map.get(i)) {
      console.log(map);
      if (stack[stack.length - 1] !== map.get(i)) return false;
      else stack.pop();
    } else {
      stack.push(i);
    }
  }
  return !stack.length;
};
```
#### 题目3：最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let sum = 0
    let ans = nums[0]
    for (let i = 0; i < nums.length; i++){
      /* 如果sum >= 0 则有益，可以保留 */
      if (sum >= 0){
        sum += nums[i]
      }else {
        /* 若sum < 0 则无益，则直接重新赋值 */
        sum = nums[i]
      }
      ans = Math.max(ans, sum)
    }
    return ans
};
```
> `Math.max()` 函数返回一组数中的最大值