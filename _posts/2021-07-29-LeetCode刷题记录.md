---
layout:     post
title:      LeetCode 刷题笔记
date:       2021-07-30
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - JavaScript
    - LeetCode
    - Notes
---
## 前言
本文会每日更新在[LeetCode](https://leetcode-cn.com/)刷题时存在的一些问题。
#### 题目1：最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。  
  
如果不存在公共前缀，返回空字符串 ""。  
```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```
```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function (strs) {
  if(strs.length === 0) return '';
  // 去第一个字符串为初始值
  let ans = strs[0];
  // 遍历数组
  for (let i = 1; i < strs.length; i++){
    // 方便后面裁截字符串
    let j = 0;
    // 遍历字符串
    for (; j < strs[i].length && j < ans.length; j++){
      // 当不匹配时退出循环，开始裁剪字符串
      if (ans[j] !== strs[i][j]){
        break;
      }
    }
    // 注意j 是截取的长度，又由于j在循环的最后一步加1，所以可以抵消字符串第一个数字为0的问题
    ans = ans.substr(0, j);
  }
  return ans;
};
```
#### 题目2：有效的括号
给定一个只包括 `'('，')'，'{'，'}'，'['，']'` 的字符串 `s` ，判断字符串是否有效。  
  
有效字符串需满足：  
- **左括号必须用相同类型的右括号闭合**。
- 左括号必须以**正确的顺序闭合**。

```
输入：s = "()[]{}"
输出：true

输入：s = "([)]"
输出：false

输入：s = "(]"
输出：false
```
**思路**：  
先将前面的入栈，如果后面的字符与入栈的最后一个字符相对应，则之前入栈的最后一个字符出栈。如果符合条件的话栈里应该为空，所以返回`!栈的长度`  
  
解法一：
```js
let isValid = function (s) {
  let stack = [],
    length = s.length;
  if (length % 2) return false;
  // 使用for of 遍历键值 如果是字符串：0对应的值1对应的值2对应的值...
  // 使用for in 遍历键名 如果是字符串：01234...
  for (let item of s) {
    // 采取入栈出栈的思路，如果正确入栈则必须出栈
    switch (item) {
      case "{":
      case "[":
      case "(":
        stack.push(item);
        break;
      case "}":
        if (stack.pop() !== "{") return false;
        break;
      case "]":
        if (stack.pop() !== "[") return false;
        break;
      case ")":
        if (stack.pop() !== "(") return false;
        break;
    }
  }
  // 如果存在多次入栈且无出栈((,则应该返回false
  return !stack.length;
};
console.log(isValid('(('));
```
解法二：
```js
var isValid = function (s) {
  s = s.split('');
  let sl = s.length;
  if (sl % 2) return false;
  let map = new Map([
    [')', '('],
    [']', '['],
    ['}', '{']
  ]);
  let stack = [];
  for (let i of s) {
    console.log(i)
    if (map.get(i)) {
      console.log(map);
      if (stack[stack.length - 1] !== map.get(i)) return false;
      else stack.pop();
    } else {
      stack.push(i);
    }
  }
  return !stack.length;
};
```
#### 题目3：最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let sum = 0
    let ans = nums[0]
    for (let i = 0; i < nums.length; i++){
      /* 如果sum >= 0 则有益，可以保留 */
      if (sum >= 0){
        sum += nums[i]
      }else {
        /* 若sum < 0 则无益，则直接重新赋值 */
        sum = nums[i]
      }
      ans = Math.max(ans, sum)
    }
    return ans
};
```
> `Math.max()` 函数返回一组数中的最大值