---
layout:     post
title:      Express
date:       2021-07-28
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - Express
    - Node.js
    - Notes
---
## 初识Express
Express的作用和Node.js 内置的http 模块类似，是专门用来创建Web 服务器的。
  
**Web 网站服务器**:专门对外提供 Web 网页资源的服务器。  
**API 接口服务器**:专门对外提供 API 接口的服务器。  
### Express的基本使用
```js
// 1、导入 express
const express = require('express')

// 2、创建web 服务器
const app = express()


// 监听get请求
app.get('/user', function(req, res){  
  // 向客户端发送 JSON 对象
  res.send({name: 'zs', age: 20, gender: '男'})
})

// 获取参数
app.get('/', (req, res) => {
  // req.query 默认是一个空对象
  // 客户端使用 ?name=zs&age=20 这种查询字符串方式，发送到服务器的参数
  // 可以通过req.query 对象访问到，例如：
  // req.query.name req.query.age
  console.log(req.query)
  res.send(req.query)
})

// 获取动态参数
app.get('/user/:id', (req, res) => {
  // req.params 是动态匹配到的URL 参数，默认也是一个空对象
  // 1、id 也可以换成其他的
  // 当输入/user/1 时， 返回的就是{ "id": "1" }

  // 2、可以写入多个动态参数 '/user/:ids/:name'
  // 当输入/user/1/2 时， 返回的就是{ "ids": "1", "name":"2" }

  console.log(req.params)
  res.send(req.params)
})

// 监听post请求
app.post('/user', function(req, res){
  // 向客户端发送文本内容
  res.send('请求成功')
})
  
// 3、调用 app.listen(端口号，启动成功后的回调函数),启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```
### 托管静态资源
`express.static()`，可以非常方便的创建一个**静态资源服务器**
```js
// 导入express
const express = require('express')

// 创建web 服务器
const app = express()

// 调用express.static(文件名)方法，快速对外 提供静态资源
app.use(express.static('./public'))
// 访问时路径中不用写./public，
// 直接访问：http://127.0.0.1/index.html

// 若需要托管多个静态资源目录，可以多次调用 express.static
// express.static() 函数会根据目录的添加顺序查找所需的文件。显示第一个托管的文件

// 启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```
#### 挂载路径前缀
如果希望在托管的静态资源访问路径之前，**挂载路径前缀**，则可以使用如下的方式:
```js
app.use('/public', express.static('./public'))
// 访问时路径中可以加上/public，
// 访问：http://127.0.0.1/public/index.html
```
#### nodemon
当我们修改了文件时，`nodemen`可以帮助我们自动重启项目，极大方便了开发和调试。
```js
// 安装nodemen
npm install -g nodemen
```
将`node` 命令替换为`nodemon` 命令，使用`nodemon app.js` 来启动项目。  
  
这样做的好处是: 代码被修改之后，会被`nodemon` 监听到，从而实现自动重启项目的效果。  
## Express路由
路由指的是**客户端的请求**与**服务器处理函数**之间的**映射关系**。  
### 初识路由
路由由三部分组成：
- 1、请求的类型
- 2、请求的URL地址
- 3、处理函数

```js
app.get('/', function(req, res){
  res.send('Hello, World!')
})

app.post('/', function(req, res){
  res.send('Got a POST request')
})
```
路由的匹配过程：当请求到达服务器之后，需要经过路由的匹配，匹配成功了，才会调用对应的处理函数，匹配时，**会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功**，则会调用处理函数。
  
**模块化路由**：
```js
/* 模块路由部分 */
// 导入 express模块
var express = require('express')

// 创建路由对象
var router = express.Router()

// 挂载获取用户列表的路由
router.get('/user/list', (req, res) => {
  res.send('Get user list.')
})

// 挂载添加用户的路由
router.post('/user/add', (req, res) => {
  res.send('Add new user.')
})

// 向外导出路由对象
module.exports = router


/* 使用路由部分 */
const express = require('express')

const app = express()

// 导入自定义模块
const router = require('./router')

// app.use()函数是来注册全局中间件
// 注册路由模块
app.use(router)

// 使用app.use() 注册路由模块，并添加统一的访问前缀 /api
// 同静态资源统一挂载访问前缀一样
// app.use('/api', router)

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
### Express中间件
当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行**预处理**。  
  
Express的中间件，本质上是一个**function处理函数**。  
  
中间件函数的参数列表中，**必须包含next参数**，而路由处理函数只包含req 和 res。  
  
**next函数**是实现**多个中间件连续调用**的关键，他表示把流转关系**转交**给下一个**中间件**或**路由**。  
#### 全局生效的中间件
客户端发起的**任何请求**，到达服务器之后，**都会触发的中间件**，叫做全局生效的中间件。  
通过调用**app.use(中间件函数)**，既可定义一个**全局生效**的中间件。
```js
const express = require('express')

const app = new express()

// 定义中间件函数
// 常量mw 所指向的，就是一个中间件函数
const mw = function (req, res, next) {
  console.log('这是一个简单的中间件函数')
  // 在当前中间件的业务处理完毕后，必须调用next() 函数
  // 表示把流转关系交给下一个 中间件或路由
  next()
}

// 将mw注册为 全局生效的中间件
app.use(mw)

// 简写形式
// app.use(function (req, res, next) {
//   console.log('这是一个简单的中间件函数')
//   next()
// })


// 路由需要放在中间件下面，才能每次访问时重新经过中间件
app.get('/', (req, res) => {
  res.send('Home Page.')
})

app.post('/user', (req, res) => {
  res.send('User Page.')
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
#### 中间件的作用
多个中间件之间，**共享同一份`req` 和`res`**。基于这样的特性，我们可以在上游的中间件中，统一为`req` 或`res` 对象添加自定义的属性或方法，**供下游的中间件或路由进行使用**。
```js
const express = require('express')

const app = new express()

// 简写形式
app.use(function (req, res, next) {
  const time = Date.now()
  req.startTime = time
  next()
})

// 路由需要放在中间件下面，才能每次访问时重新经过中间件
app.get('/', (req, res) => {
  res.send('Home Page.' + req.startTime)
})

app.post('/user', (req, res) => {
  res.send('User Page.'+ req.startTime)
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
#### 局部生效的中间件
不使用`app.use()`定义的中间件，叫做**局部生效的中间件**
```js
const express = require('express')

const app = express()

// 定义中间件函数 mw1
const mw1 = function(req, res, next){
  console.log('调用了局部中间件')
  next()
}

//  创建路由
app.get('/', mw1, (req, res) => {
  res.send("Home Page.") // 只有这个路由会调用中间件
})

app.get('/user', (req, res) => {
  res.send("User Page.")
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
#### 定义多个局部中间件
```js
// 第一种方式
// app.get('/', mw1, mw2, (req, res) => {
//   res.send("Home Page.") // 只有这个路由会调用中间件
// })
// 第二种方式
app.get('/',[mw1, mw2], (req, res) => {
  res.send("Home Page.") // 只有这个路由会调用中间件
})
```
#### 中间件的分类
- 应用级别的中间件
- 路由级别的中间件
- 错误级别的中间件
- Express 内置的中间件 
- 第三方的中间件

##### 应用级别的中间件
通过`app.use()`、`app.get()`、`app.post()`，绑定到app实例上的**中间件**，叫做应用级别的中间件。  
```js
// 全局中间件
app.use((req, res) => {
  next()
})

// 局部中间件
app.get('/', mw1, (req, res) => {
  res.send("Home page.")
})
```
##### 路由级别的中间件
绑定到`express.Router()`实例上的中间件，叫做路由级别的中间件。和**应用级别的区别是应用级别的中间件是绑定在app实例上，路由级别的中间件是绑定到router实例上**。
```js
router.use(function(req, res, next){
  console.log('路由级别中间件')
  next()
})
```
##### 错误级别的中间件
专门用来**捕获**整个项目中发生的**异常错误**，从而**防止项目异常崩溃的问题**。  
  
错误级别中间件的`function 处理函数`中，必须有4 个形参，形参顺序从前到后，分别是`(err, req, res, next)`。
```js
const express = require('express')

const app = express()

app.get('/', (req, res) => {
  throw new Error('服务器内部发送错误') // 抛出一个自定义的错误
  res.send('Home Pages.') // 当发生错误时，后面就不执行了
})

// 错误级别的中间件，当发生错误时，捕获发送的异常信息，从而阻止程序的崩溃
app.use((err, req, res, next) => {
  // 在服务器打印错误信息
  console.log('发生了错误: ' + err.message)
  // 向客户端打印错误信息
  res.send('Error! ' + err.message)
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
> 错误级别的中间件，必须注册在所有路由之后

##### Express内置的中间件
- `express.static` 快速**托管静态资源**的内置中间件，例如: HTML 文件、图片、CSS 样式等
- `express.json` 解析`JSON` 格式的请求体数据
- `express.urlencoded` 解析`URL-encoded` 格式的请求体数据

```js
// express.json()
const express = require('express')

const app = express()

// 通过express.json() 这个中间件， 解析表单中的 JSON格式的数据 
app.use(express.json())
app.post('/user', (req, res) => {
  // req.body 这个属性，接收客户端发送来的请求体数据
  // 默认情况下，如果不配置解析表单数据的中间件，则req.body 默认等于undefined
  console.log(req.body) // { name: 'zhangsan', age: 18 }
  res.send('ok')
})

// 通过express.urlencoded() 这个中间件，来解析表单中的url-encoded格式的数据
// 固定写法
app.use(express.urlencoded({extends: false}))
app.post('/book', (req, res) => {
  // 在服务器端，可以通过req.body 来获取JSON格式的表单数据和 url-encoded格式的数据
  console.log(req.body) // { bookname: '水浒传', autohr: '施耐庵' }
  res.send('ok')
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
##### 第三方的中间件
按需下载并配置第三方中间件，从而提高开发效率。  
## 使用Express写接口
