---
layout:     post
title:      Express
date:       2021-07-28
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - Express
    - Node.js
    - Notes
---
## 初识Express
Express的作用和Node.js 内置的http 模块类似，是专门用来创建Web 服务器的。
  
**Web 网站服务器**:专门对外提供 Web 网页资源的服务器。  
**API 接口服务器**:专门对外提供 API 接口的服务器。  
### Express的基本使用
```js
// 1、导入 express
const express = require('express')

// 2、创建web 服务器
const app = express()

// 监听get请求
app.get('/user', function(req, res){  
  // 向客户端发送 JSON 对象
  res.send({name: 'zs', age: 20, gender: '男'})
})

// 获取参数
app.get('/', (req, res) => {
  // req.query 默认是一个空对象
  // 客户端使用 ?name=zs&age=20 这种查询字符串方式，发送到服务器的参数
  // 可以通过req.query 对象访问到，例如：
  // req.query.name req.query.age
  console.log(req.query)
  res.send(req.query)
})

// 获取动态参数
app.get('/user/:id', (req, res) => {
  // req.params 是动态匹配到的URL 参数，默认也是一个空对象
  // 1、id 也可以换成其他的
  // 当输入/user/1 时， 返回的就是{ "id": "1" }

  // 2、可以写入多个动态参数 '/user/:ids/:name'
  // 当输入/user/1/2 时， 返回的就是{ "ids": "1", "name":"2" }

  console.log(req.params)
  res.send(req.params)
})

// 监听post请求
app.post('/user', function(req, res){
  // 向客户端发送文本内容
  res.send('请求成功')
})
  
// 3、调用 app.listen(端口号，启动成功后的回调函数),启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```
### 托管静态资源
`express.static()`，可以非常方便的创建一个**静态资源服务器**，需要使用`app.use()`
```js
// 导入express
const express = require('express')

// 创建web 服务器
const app = express()

// 调用express.static(文件名)方法，快速对外 提供静态资源
app.use(express.static('./public'))
// 访问时路径中不用写./public，
// 直接访问：http://127.0.0.1/index.html

// 若需要托管多个静态资源目录，可以多次调用 express.static
// express.static() 函数会根据目录的添加顺序查找所需的文件。显示第一个托管的文件

// 启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```
#### 挂载路径前缀
如果希望在托管的静态资源访问路径之前，**挂载路径前缀**，则可以使用如下的方式:
```js
app.use('/public', express.static('./public'))
// 访问时路径中可以加上/public，
// 访问：http://127.0.0.1/public/index.html
```
#### nodemon
当我们修改了文件时，`nodemen`可以帮助我们自动重启项目，极大方便了开发和调试。
```js
// 安装nodemen
npm install -g nodemen
```
将`node` 命令替换为`nodemon` 命令，使用`nodemon app.js` 来启动项目。  
  
这样做的好处是: 代码被修改之后，会被`nodemon` 监听到，从而实现自动重启项目的效果。  
## Express路由
路由指的是**客户端的请求**与**服务器处理函数**之间的**映射关系**。  
### 初识路由
路由由三部分组成：
- 1、请求的类型
- 2、请求的URL地址
- 3、处理函数

```js
app.get('/', function(req, res){
  res.send('Hello, World!')
})

app.post('/', function(req, res){
  res.send('Got a POST request')
})
```
路由的匹配过程：当请求到达服务器之后，需要经过路由的匹配，匹配成功了，才会调用对应的处理函数，匹配时，**会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功**，则会调用处理函数。
  
**模块化路由**：
```js
/* 模块路由部分 */
// 导入 express模块
var express = require('express')

// 创建路由对象
var router = express.Router()

// 挂载获取用户列表的路由
router.get('/user/list', (req, res) => {
  res.send('Get user list.')
})

// 挂载添加用户的路由
router.post('/user/add', (req, res) => {
  res.send('Add new user.')
})

// 向外导出路由对象
module.exports = router


/* 使用路由部分 */
const express = require('express')

const app = express()

// 导入自定义模块
const router = require('./router')

// app.use()函数是来注册全局中间件
// 注册路由模块
app.use(router)

// 使用app.use() 注册路由模块，并添加统一的访问前缀 /api
// 同静态资源统一挂载访问前缀一样
// app.use('/api', router)

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
### Express中间件
当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行**预处理**。  
  
Express的中间件，本质上是一个**function处理函数**。  
  
中间件函数的参数列表中，**必须包含next参数**，而路由处理函数只包含req 和 res。  
  
**next函数**是实现**多个中间件连续调用**的关键，他表示把流转关系**转交**给下一个**中间件**或**路由**。  
#### 全局生效的中间件
客户端发起的**任何请求**，到达服务器之后，**都会触发的中间件**，叫做全局生效的中间件。  
通过调用**app.use(中间件函数)**，既可定义一个**全局生效**的中间件。
```js
const express = require('express')

const app = express()

// 定义中间件函数
// 常量mw 所指向的，就是一个中间件函数
const mw = function (req, res, next) {
  console.log('这是一个简单的中间件函数')
  // 在当前中间件的业务处理完毕后，必须调用next() 函数
  // 表示把流转关系交给下一个 中间件或路由
  next()
}

// 将mw注册为 全局生效的中间件
app.use(mw)

// 简写形式
// app.use(function (req, res, next) {
//   console.log('这是一个简单的中间件函数')
//   next()
// })


// 路由需要放在中间件下面，才能每次访问时重新经过中间件
app.get('/', (req, res) => {
  res.send('Home Page.')
})

app.post('/user', (req, res) => {
  res.send('User Page.')
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
#### 中间件的作用
多个中间件之间，**共享同一份`req` 和`res`**。基于这样的特性，我们可以在上游的中间件中，统一为`req` 或`res` 对象添加自定义的属性或方法，**供下游的中间件或路由进行使用**。
```js
const express = require('express')

const app = express()

// 简写形式
app.use(function (req, res, next) {
  const time = Date.now()
  req.startTime = time
  next()
})

// 路由需要放在中间件下面，才能每次访问时重新经过中间件
app.get('/', (req, res) => {
  res.send('Home Page.' + req.startTime)
})

app.post('/user', (req, res) => {
  res.send('User Page.'+ req.startTime)
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
#### 局部生效的中间件
不使用`app.use()`定义的中间件，叫做**局部生效的中间件**
```js
const express = require('express')

const app = express()

// 定义中间件函数 mw1
const mw1 = function(req, res, next){
  console.log('调用了局部中间件')
  next()
}

//  创建路由
app.get('/', mw1, (req, res) => {
  res.send("Home Page.") // 只有这个路由会调用中间件
})

app.get('/user', (req, res) => {
  res.send("User Page.")
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
#### 定义多个局部中间件
```js
// 第一种方式
// app.get('/', mw1, mw2, (req, res) => {
//   res.send("Home Page.") // 只有这个路由会调用中间件
// })
// 第二种方式
app.get('/',[mw1, mw2], (req, res) => {
  res.send("Home Page.") // 只有这个路由会调用中间件
})
```
#### 中间件的分类
- 应用级别的中间件
- 路由级别的中间件
- 错误级别的中间件
- Express 内置的中间件 
- 第三方的中间件

##### 应用级别的中间件
通过`app.use()`、`app.get()`、`app.post()`，绑定到app实例上的**中间件**，叫做应用级别的中间件。  
```js
// 全局中间件
app.use((req, res) => {
  next()
})

// 局部中间件
app.get('/', mw1, (req, res) => {
  res.send("Home page.")
})
```
##### 路由级别的中间件
绑定到`express.Router()`实例上的中间件，叫做路由级别的中间件。和**应用级别的区别是应用级别的中间件是绑定在app实例上，路由级别的中间件是绑定到router实例上**。
```js
router.use(function(req, res, next){
  console.log('路由级别中间件')
  next()
})
```
##### 错误级别的中间件
专门用来**捕获**整个项目中发生的**异常错误**，从而**防止项目异常崩溃的问题**。  
  
错误级别中间件的`function 处理函数`中，必须有4 个形参，形参顺序从前到后，分别是`(err, req, res, next)`。
```js
const express = require('express')

const app = express()

app.get('/', (req, res) => {
  throw new Error('服务器内部发送错误') // 抛出一个自定义的错误
  res.send('Home Pages.') // 当发生错误时，后面就不执行了
})

// 错误级别的中间件，当发生错误时，捕获发送的异常信息，从而阻止程序的崩溃
app.use((err, req, res, next) => {
  // 在服务器打印错误信息
  console.log('发生了错误: ' + err.message)
  // 向客户端打印错误信息
  res.send('Error! ' + err.message)
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
> 错误级别的中间件，必须注册在所有路由之后

##### Express内置的中间件
- `express.static` 快速**托管静态资源**的内置中间件，例如: HTML 文件、图片、CSS 样式等
- `express.json` 解析`JSON` 格式的请求体数据
- `express.urlencoded` 解析`URL-encoded` 格式的请求体数据

```js
// express.json()
const express = require('express')

const app = express()

// 通过express.json() 这个中间件， 解析表单中的 JSON格式的数据 
app.use(express.json())
app.post('/user', (req, res) => {
  // req.body 这个属性，接收客户端发送来的请求体数据
  // 默认情况下，如果不配置解析表单数据的中间件，则req.body 默认等于undefined
  console.log(req.body) // { name: 'zhangsan', age: 18 }
  res.send('ok')
})

// 通过express.urlencoded() 这个中间件，来解析表单中的url-encoded格式的数据
// 固定写法
app.use(express.urlencoded({extends: false}))
app.post('/book', (req, res) => {
  // 在服务器端，可以通过req.body 来获取JSON格式的表单数据和 url-encoded格式的数据
  console.log(req.body) // { bookname: '水浒传', autohr: '施耐庵' }
  res.send('ok')
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```
##### 第三方的中间件
按需下载并配置第三方中间件，从而提高开发效率。  
## 使用Express写接口
```js
/* 创建api路由模块 */
const express = require('express')

const router = express.Router()

/* 编写get接口 */
router.get('/get', (req, res) => {
  const query = req.query

  res.send({
    status: 0,        // 0 表示处理成功
    msg: 'GET请求成功', // 状态描述
    data: query       // 响应给客户端的数据
  })
})

/* 编写post接口 */
router.post('/post', (req, res) => {
  const body = req.body

  res.send({
    status: 0, // 0 表示处理成功
    msg: 'POST请求成功', // 状态描述
    data: body // 响应给客户端的数据
  })
})

module.exports = router

/* 创建基本的服务器 */
const express = require('express')
// 创建服务器实例
const app = express()

app.use(express.urlencoded({extended: false}))

const router = require('./router')
// 把路由模块，注册到app 上
app.use('/api', router)

app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```
### CORS跨域资源共享
解决接口跨域问题的主要方案有两种：
- 1、CORS(主流解决方案)
- 2、JSONP(只支持GET请求)

`cors`是Express的一个第三方中间件，通过安装和配置cors中间件，可以很方便的解决跨域问题。  
- 1、`npm i cors` 安装中间件
- 2、`const cors = require('cors')` 导入中间件
- 3、在路由之前调用`app.use(cors())` 配置中间件

CORS由一系列**HTTP响应头**(描述服务器的基本信息)组成，这些**HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源**。  
  
浏览器的**同源安全策略**默认会阻止网页**跨域**获取资源。但如果接口服务器**配置了CORS 相关的HTTP 响应头**， 就可以**解除浏览器端的跨域访问限制**。  
  
`CORS` 主要在**服务器端**进行配置。客户端浏览器**无须做任何额外的配置**，即可请求开启了`CORS` 的接口。  
  
`CORS` 在浏览器中有**兼容性**。只有支持`XMLHttpRequest Level2` 的浏览器，才能正常访问开启了`CORS` 的服务端接口(例如:IE10+、Chrome4+、FireFox3.5+)。  
  
#### CORS响应头
##### Access-Control-Allow-Origin
响应头可以携带一个`Access-Control-Allow-Origin`  
  
只允许来自`https://pengpeng-qi.github.io/`的请求：
```js
res.setHeader('Access-Control-Allow-Origin', 'https://pengpeng-qi.github.io/')
```
允许来自任何域的请求
```js
res.setHeader('Access-Control-Allow-Origin', '*')
```
##### Access-Control-Allow-Methods
默认情况下，`CORS` 仅支持客户端发起`GET、POST、HEAD` 请求。  
如果客户端希望通过`PUT、DELETE` 等方式请求服务器的资源，则需要在服务器端，通过`Access-Control-Alow-Methods` 来**指明实际请求所允许使用的 HTTP 方法**。  
  
```js
// 只允许POST、GET、DELETE、HEAD 请求的方法
res.setHeader('Access-Control-Allow-Header', 'POST, GET, DELETE, HEAD')

// 允许所有的HTTP 请求方法
res.setHeader('Access-Control-Allow-Header', '*')
```
#### CORS请求的分类
- 简单请求
- 预检请求

##### 简单请求
**请求方式**:`GET、POST、HEAD` 三者之一  
##### 预检请求
在浏览器与服务器正式通信之前，浏览器会**先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求**，所以这一次的 OPTION 请求称为“预检请求”。**服务器成功响应预检请求后，才会发送真正的请求**，并且携带真实数据。
##### 简单请求和预检请求的区别
简单请求的特点:客户端与服务器之间**只会发生一次请求**。  
预检请求的特点:客户端与服务器之间**会发生两次请求**，OPTION 预检请求成功之后，才会发起真正的请求。

#### JSONP接口
```js
/* 接口部分 */
// 为了防止冲突，需要在cors中间件之前，配置 JSONP接口
app.get('/api/jsonp', (req, res) => {
  // 定义JSONP接口 具体实现过程
  // 1 获取客户端发送过来的回调函数的名字
  const funcName = req.query.callback
  // 2 得到要通过 JSONP 形式发送给客户端的数据
  const data = { name: 'zs', age: 32}
  // 3 根据前两步得到的数据， 拼接出一个函数调用的字符串
  const scriptStr = `${funcName}(${JSON.stringify(data)})`
  // 4 把上一步拼接得到的字符串， 响应给客户端的 <script> 标签进行解析执行
  res.send(scriptStr)
})

/* 客户端部分 */
$('.JSONP').on('click', function(){
  $.ajax({
    type: 'POST',
    url: 'http://127.0.0.1/api/jsonp',
    dataType: 'jsonp',
    success: function(res){
      console.log(res);
    }
  })
})
```