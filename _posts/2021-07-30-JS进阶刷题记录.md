---
layout:     post
title:      JS进阶 刷题笔记
date:       2021-07-30
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - JavaScript
    - Notes
---
## 前言
本文源于在GitHub上发现的[javascript-questions](https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md)，接下来会不定期更新自己的刷题笔记
### 题目1
```js
+true;
!"Lydia";
```
- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

> A、一元操作符加号尝试将 bool 转为 number。true 转换为 number 的话为 1，false 为 0。字符串 'Lydia' 是一个真值，真值取反那么就返回 false。  
> 关于一元操作符的更多内容可参见[ECMAScript 一元运算符](https://www.w3school.com.cn/js/pro_js_operators_unary.asp)

### 题目2
```js
const bird = {
  size: 'small'
}

const mouse = {
  name: 'Mickey',
  small: true
}
```
- A: `mouse.bird.size`是无效的
- B: `mouse[bird.size]`是无效的
- C: `mouse[bird["size"]]`是无效的
- D: 以上三个选项都是有效的

> A、JavaScript会解释语句，会先看到第一个括号，然后开始解析，然后看到第二个括号，由于`mouse`没有`bird`这个`key`， 所以`mouse.brid`是·`undefined`

### 题目3
```js
let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
```
- A: `Hello`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

> A、let关键字声明的变量，不能重新声明，但是可以重新赋值，由于c 是一个对象(复杂数据类型)，所以赋值赋的是栈里地址，改变的是堆里的内容，改变内容之后，地址没变，内容变了，所以d 也随着变了

### 题目4
```js
let greeting
greetign = {} 
console.log(greetign)
```
- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

> A、注意`greeting`和`greetign`不一样，所以相当于`greetign`没有声明直接赋值，

```js
var a = 1;
b = 2;

delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。
delete this.b;

console.log(a, b); // 抛出ReferenceError。
// 'b'属性已经被删除。
```
> 可参考[Var 描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var)

### 题目5
```js
function bark() {
  console.log('Woof!')
}

bark.animal = 'dog'
/* 
    console.log(bark);
    ƒ bark() {
    console.log('Woof!')
    } 
*/
/* 
    console.log(bark());
    Woof! 
*/
```
- A: `正常运行!`
- B: `SyntaxError. 你不能通过这种方式给函数增加属性。`
- C: `undefined`
- D: `ReferenceError`
`
> A、这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）  
> 函数是一个特殊的对象。函数是一个拥有属性的对象，并且属性也可被调用。

### 题目6
```js
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

const lydia = new Person('Lydia', 'Hallie')
const sarah = Person('Sarah', 'Smith')

console.log(lydia)
console.log(sarah)
// console.log(firstName) // Sarah
```
- A: `Person {firstName: "Lydia", lastName: "Hallie"} and undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"} and Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"} and {}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"} and ReferenceError`

> A、对于`sarah`，我们没有使用`new` 关键字。当使用`new` 时，`this`引用我们创建的空对象。当未使用`new` 时，`this` 引用的是**全局对象（global object）**。  
> 我们说`this.firstName` 等于 `"Sarah"`，并且 `this.lastName`等于 `"Smith"`。实际上我们做的是，定义了 `global.firstName = 'Sarah'` 和 `global.lastName = 'Smith'`。而 `sarah` 本身是 `undefined`。

### 题目7
```js
function sum(a, b) {
  return a + b
}

sum(1, '2')
```
- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

> C、此时1会被转换为字符串形式

### 题目8
```js
function getPersonInfo(one, two, three) {
  console.log(one)
  console.log(two)
  console.log(three)
}

const person = 'Lydia'
const age = 21

getPersonInfo`${person} is ${age} years old`
```
- A: `"Lydia" 21 ["", " is ", " years old"]`
- B: `["", " is ", " years old"] "Lydia" 21`
- C: `"Lydia" ["", " is ", " years old"] 21`

> B、使用标记模版字面量，第一个参数的值总是包含字符串的数组，其余的参数获取的是传递的表达式的值！

### 题目9
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!')
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.')
  } else {
    console.log(`Hmm.. You don't have an age I guess`)
  }
}

checkAge({ age: 18 }) // `Hmm.. You don't have an age I guess`
```
- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

> C、在测试相等时，简单数据类型通过值比较、复杂数据类型通过引用地址比较，地址相同，才表示相同，题目中我们正在比较的两个对象不是同一个引用

```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!')
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.')
  } else {
    console.log(`Hmm.. You don't have an age I guess`)
  } 
}
var lili = {age: 18};
checkAge(lili);
// You are still an adult.
```
> 1、《Javascript高级程序设计第四版》10.3小结末尾提到：**ECMAScript中所有的参数都是按值传递的，不可能按引用传递参数，如果把对象作为参数传递，那么传递的值就是这个对象的引用**。  
> 2、帮助理解可参考[JS参数传递（值传递和引用传递）](https://blog.csdn.net/weixin_39728230/article/details/80607294?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)的评论区。  

### 题目10
```js
function getAge(...args) {
  console.log(typeof args);
  // console.log(...args); // 21
}

getAge(21)
```
- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

> C、扩展运算符（`...args`）会返回实参组成的**数组**。而**数组是对象**，因此 typeof args 返回 "object"。

```js
function sum (...args) { 
    console.log(...args); // 10, 20, 30
    console.log(args); // [10, 20, 30]
}
sum(10, 20, 30)
```
### 题目11
```js
function getAge() {
  'use strict'
  age = 21
  console.log(age)
}

getAge()
```
- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

> C、使用`use strict`可以确保不会意外地声明全局变量，所以就会抛出一个引用错误

### 题目12
```js
const sum = eval('10*10+5')
```
- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

> A、`eval()` 函数会将传入的字符串当做 JavaScript 代码进行执行。返回字符串中代码的返回值。如果返回值为空，则返回 undefined。

### 题目13
```js
// 可访问时长
sessionStorage.setItem('cool_secret', 123)
```
- A: `永远，数据不会丢失。`
- B: `当用户关掉标签页时。`
- C: `当用户关掉整个浏览器，而不只是关掉标签页。`
- D: `当用户关闭电脑时。`

> 1、关闭 `tab` 标签页 后，`sessionStorage` 存储的数据才会删除。  
> 2、如果使用`localStorage`，那么数据将永远在那里，除非调用了 `localStorage.clear()`。

### 题目14
```js
const obj = { 1: 'a', 2: 'b', 3: 'c' }
const set = new Set([1, 2, 3, 4, 5])

obj.hasOwnProperty('1')
obj.hasOwnProperty(1)
set.has('1')
set.has(1)
```
- A: `false true false true`
- B: `false true true true`
- C: `true true false true`
- D: `true true true true`

> C、所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。`hasOwnProperty()` 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。  
> 对于集合，它不是这样工作的。在我们的集合中没有 `'1'`：`set.has('1')` 返回 `false`。它有数字类型为 `1`，`set.has(1)` 返回 true。  

### 题目15
```js
const obj = { a: 'one', b: 'two', a: 'three' }
console.log(obj)
```
- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

> C、如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。