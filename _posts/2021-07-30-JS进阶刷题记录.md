---
layout:     post
title:      JS进阶 刷题笔记
date:       2021-07-30
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - JavaScript
    - Notes
---
## 前言
本文源于在GitHub上发现的[javascript-questions](https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md)，接下来会不定期更新自己的刷题笔记
### 题目1
```js
+true;
!"Lydia";
```
- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

> A、一元操作符加号尝试将 bool 转为 number。true 转换为 number 的话为 1，false 为 0。字符串 'Lydia' 是一个真值，真值取反那么就返回 false。  
> 关于一元操作符的更多内容可参见[ECMAScript 一元运算符](https://www.w3school.com.cn/js/pro_js_operators_unary.asp)

### 题目2
```js
const bird = {
  size: 'small'
}

const mouse = {
  name: 'Mickey',
  small: true
}
```
- A: `mouse.bird.size`是无效的
- B: `mouse[bird.size]`是无效的
- C: `mouse[bird["size"]]`是无效的
- D: 以上三个选项都是有效的

> A、JavaScript会解释语句，会先看到第一个括号，然后开始解析，然后看到第二个括号，由于`mouse`没有`bird`这个`key`， 所以`mouse.brid`是·`undefined`

### 题目3
```js
let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
```
- A: Hello
- B: undefined
- C: ReferenceError
- D: TypeError

> A、let关键字声明的变量，不能重新声明，但是可以重新赋值，由于c 是一个对象(复杂数据类型)，所以赋值赋的是栈里地址，改变的是堆里的内容，改变内容之后，地址没变，内容变了，所以d 也随着变了

### 题目3
```js
let greeting
greetign = {} 
console.log(greetign)
```
- A: {}
- B: ReferenceError: greetign is not defined
- C: undefined

> A、注意`greeting`和`greetign`不一样，所以相当于`greetign`没有声明直接赋值，

```js
var a = 1;
b = 2;

delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。
delete this.b;

console.log(a, b); // 抛出ReferenceError。
// 'b'属性已经被删除。
```
> 可参考[Var 描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var)

### 题目4
```js
function bark() {
  console.log('Woof!')
}

bark.animal = 'dog'
/* 
    console.log(bark);
    ƒ bark() {
    console.log('Woof!')
    } 
*/
/* 
    console.log(bark());
    Woof! 
*/
```
- A: 正常运行!
- B: SyntaxError. 你不能通过这种方式给函数增加属性。
- C: undefined
- D: ReferenceError

> A、这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）  
> 函数是一个特殊的对象。函数是一个拥有属性的对象，并且属性也可被调用。

### 题目5
```js
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

const lydia = new Person('Lydia', 'Hallie')
const sarah = Person('Sarah', 'Smith')

console.log(lydia)
console.log(sarah)
// console.log(firstName) // Sarah
```
- A: `Person {firstName: "Lydia", lastName: "Hallie"} and undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"} and Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"} and {}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"} and ReferenceError`

> A、对于`sarah`，我们没有使用`new` 关键字。当使用`new` 时，`this`引用我们创建的空对象。当未使用`new` 时，`this` 引用的是**全局对象（global object）**。  
> 我们说`this.firstName` 等于 `"Sarah"`，并且 `this.lastName`等于 `"Smith"`。实际上我们做的是，定义了 `global.firstName = 'Sarah'` 和 `global.lastName = 'Smith'`。而 `sarah` 本身是 `undefined`。