---
layout:     post
title:      JS进阶 刷题笔记
date:       2021-07-30
author:     PengPengQi
header-img: img/BackGround.png
catalog: true
tags:
    - JavaScript
    - Notes
---
## 前言
本文源于在GitHub上发现的[javascript-questions](https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md)，接下来会不定期更新自己的刷题笔记
### 题目1
```js
+true;
!"Lydia";
```
- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

> A、一元操作符加号尝试将 bool 转为 number。true 转换为 number 的话为 1，false 为 0。字符串 'Lydia' 是一个真值，真值取反那么就返回 false。  
> 关于一元操作符的更多内容可参见[ECMAScript 一元运算符](https://www.w3school.com.cn/js/pro_js_operators_unary.asp)

### 题目2
```js
const bird = {
  size: 'small'
}

const mouse = {
  name: 'Mickey',
  small: true
}
```
- A: `mouse.bird.size`是无效的
- B: `mouse[bird.size]`是无效的
- C: `mouse[bird["size"]]`是无效的
- D: 以上三个选项都是有效的

> A、JavaScript会解释语句，会先看到第一个括号，然后开始解析，然后看到第二个括号，由于`mouse`没有`bird`这个`key`， 所以`mouse.brid`是·`undefined`

### 题目3
```js
let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
```
- A: `Hello`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

> A、let关键字声明的变量，不能重新声明，但是可以重新赋值，由于c 是一个对象(复杂数据类型)，所以赋值赋的是栈里地址，改变的是堆里的内容，改变内容之后，地址没变，内容变了，所以d 也随着变了

### 题目4
```js
let greeting
greetign = {} 
console.log(greetign)
```
- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

> A、注意`greeting`和`greetign`不一样，所以相当于`greetign`没有声明直接赋值，

```js
var a = 1;
b = 2;

delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。
delete this.b;

console.log(a, b); // 抛出ReferenceError。
// 'b'属性已经被删除。
```
> 可参考[Var 描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var)

### 题目5
```js
function bark() {
  console.log('Woof!')
}

bark.animal = 'dog'
/* 
    console.log(bark);
    ƒ bark() {
    console.log('Woof!')
    } 
*/
/* 
    console.log(bark());
    Woof! 
*/
```
- A: `正常运行!`
- B: `SyntaxError. 你不能通过这种方式给函数增加属性。`
- C: `undefined`
- D: `ReferenceError`
`
> A、这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）  
> 函数是一个特殊的对象。函数是一个拥有属性的对象，并且属性也可被调用。

### 题目6
```js
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

const lydia = new Person('Lydia', 'Hallie')
const sarah = Person('Sarah', 'Smith')

console.log(lydia)
console.log(sarah)
// console.log(firstName) // Sarah
```
- A: `Person {firstName: "Lydia", lastName: "Hallie"} and undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"} and Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"} and {}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"} and ReferenceError`

> A、对于`sarah`，我们没有使用`new` 关键字。当使用`new` 时，`this`引用我们创建的空对象。当未使用`new` 时，`this` 引用的是**全局对象（global object）**。  
> 我们说`this.firstName` 等于 `"Sarah"`，并且 `this.lastName`等于 `"Smith"`。实际上我们做的是，定义了 `global.firstName = 'Sarah'` 和 `global.lastName = 'Smith'`。而 `sarah` 本身是 `undefined`。

### 题目7
```js
function sum(a, b) {
  return a + b
}

sum(1, '2')
```
- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

> C、此时1会被转换为字符串形式

### 题目8
```js
function getPersonInfo(one, two, three) {
  console.log(one)
  console.log(two)
  console.log(three)
}

const person = 'Lydia'
const age = 21

getPersonInfo`${person} is ${age} years old`
```
- A: `"Lydia" 21 ["", " is ", " years old"]`
- B: `["", " is ", " years old"] "Lydia" 21`
- C: `"Lydia" ["", " is ", " years old"] 21`

> B、使用标记模版字面量，第一个参数的值总是包含字符串的数组，其余的参数获取的是传递的表达式的值！

### 题目9
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!')
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.')
  } else {
    console.log(`Hmm.. You don't have an age I guess`)
  }
}

checkAge({ age: 18 }) // `Hmm.. You don't have an age I guess`
```
- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

> C、在测试相等时，简单数据类型通过值比较、复杂数据类型通过引用地址比较，地址相同，才表示相同，题目中我们正在比较的两个对象不是同一个引用

```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!')
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.')
  } else {
    console.log(`Hmm.. You don't have an age I guess`)
  } 
}
var lili = {age: 18};
checkAge(lili);
// You are still an adult.
```
> 1、《Javascript高级程序设计第四版》10.3小结末尾提到：**ECMAScript中所有的参数都是按值传递的，不可能按引用传递参数，如果把对象作为参数传递，那么传递的值就是这个对象的引用**。  
> 2、帮助理解可参考[JS参数传递（值传递和引用传递）](https://blog.csdn.net/weixin_39728230/article/details/80607294?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)的评论区。  

### 题目10
```js
function getAge(...args) {
  console.log(typeof args);
  // console.log(...args); // 21
}

getAge(21)
```
- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

> C、扩展运算符（`...args`）会返回实参组成的**数组**。而**数组是对象**，因此 typeof args 返回 "object"。

```js
function sum (...args) { 
    console.log(...args); // 10, 20, 30
    console.log(args); // [10, 20, 30]
}
sum(10, 20, 30)
```