## Node.js与内置模块
### Node.js
**Node.js**是一个基于Chrome V8引擎的JavaScript的**后端运行环境**。  
**浏览器**是JavaScript的**前端运行环境**。  

基于`Express`可以快速构建Web应用、基于`Electron`可以跨平台构建桌面应用、基于`restify`可以快速构建API接口项目  

**Node.js**环境执行JS代码：打开终端、输入node要执行的js文件路径  
### fs系统模块
- `fs.readFile()`方法，用来**读取指定文件**中的内容
- `fs.writeFile()`方法，用来向指定的文件中**写入内容**、只能用来创建文件，而不能用来创建路径

如果要在JS代码中使用fs模块，需要先导入他`const fs = require('fs')`
  
使用`fs.readFile()`方法，可以**读取指定文件中的内容**，语法格式如下：`fs.readFile(path[, option], callback)`
  
- `path`必选参数，字符串，表示文件的路径
- `option`，可选参数，表示以什么**编码格式**来读取文件
- `callback`，必选参数，文件读取完成后，可以通过回调函数拿到读取的结果
  
```js
const fs = require('fs');

fs.readFile('../txt.txt', 'utf8', function(err, res){
  if (err) {
    return console.log('读取信息失败', err);
  };
  console.log(res);
})
```
`fs.writeFile()`方法，用来向指定的文件中写入内容
  - `file`：**必选**参数，指定一个**文件路径的字符串**，表示文件的存储路径
  - `data`：**必选**参数，表示要写入的内容
  - `option`：可选参数，表示以什么格式写入文件内容，默认值是utf8
  - `callback`：**必选**参数，文件写入完成后的回调函数
```js
fs.writeFile(file, data[, option], callback)
```
```js
const fs = require('fs');

fs.writeFile('.../我是用fs写的文件.txt', 'Hello, World!', 'utf8', function(err){
  err ? console.log('文件写入失败: ', err) : console.log('文件写入成功');
})
```
> 当我们在terminal中使用node允许js是，如果没有在js所在文件夹，使用上面的路径方式容易引起路径出错问题

我们常使用`__dirname` 可显示当前文件存放的位置,且不需要导入模块使用，即可显示文件所在所在位置，常用于文件拼接时
```js
console.log(__dirname); // /Users/pengqi/Documents/GitHub/PengPeng-Qi.github.io/demo/Node/FS
```

### path模块
path模块是官方提供的、用来**处理路径**的模块
- `path.join([...paths])`：用来将**多个路径片段拼接成一个完整的路径字符串**
- `path.basename()`：用来从路径字符串中，将**文件名解析**出来
- `path.extname()`：用来获取路径中的拓展名部分

#### path.join()
```js
const path = require('path');

const pathStr = path.join('/a', '/b/c');
console.log(pathStr); // /a/b/c

const pathStr1 = path.join('/a', '/b/c', '../'); // ../等同于回退一个文件夹
console.log(pathStr1); // /a/b/

const pathStr2 = path.join('/a', '/b/c', './d'); // ./d 等同于/d
console.log(pathStr2); // /a/b/c/d

const pathStr2 = path.join(__dirname, './files/text.txt'); 
const pathStr2 = path.join(__dirname, '/files/text.txt'); //使用path.join上面两种方式结果一致

const pathStr2 = (__dirname + './files/text.txt');
const pathStr2 = (__dirname + '/files/text.txt');  // 使用 + 上面两种方式结果不一致

// 凡事涉及到路径问题，都要使用path.join()方法进行处理，不要使用 + 进行字符串拼接
```
#### path.basename() && path.extname()
`path.basename(path[, ext])`：用来从路径字符串中，将**文件名解析**出来(ext表示文件拓展名)  
`path.extname(path)`：用来获取路径中的拓展名部分
```js
// path.join()将多个路径结合
const fpath = path.join(__dirname, '/a/b/c/index.html');

// path.basename将文件名解析出来
const fullName = path.basename(fpath);  // index.html

// path.extname将拓展名解析出来
const ftext = path.extname(fpath);      // .html
```
### HTTP模块
http 模块提供的 `http.createServer()`方法，能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。  
  
可以使用`ping www.baidu.com`命令，查看到百度服务器的 IP 地址。  
  
域名服务器(DNS): 提供**域名**与**ip地址**之间互相转换的服务器。  
  
#### 创建最基本的web服务器
- 1、导入http模版
- 2、创建web服务器实例
- 3、为服务器实例绑定`request`事件，**监听客户端的请求**
- 4、启动服务器

```js
// 导入http模块
const http = require('http')

// 创建web服务器实例
const server = http.createServer()

// 为服务器实例绑定request事件,即可监听客户端发送过来的网络请求
server.on('request', (req, res) => {
  // 只要有客户端来请求我们自己的服务器，就会触发request事件，从而调用这个事件处理函数
  // req 是请求对象，包含了与客户端相关的属性和数据
  // req.url 是客户端请求的URL 地址
  // req.method 是客户端的method 请求类型
  const str = `你请求 url is ${req.url}, and request method is ${req.method}`
  console.log(str)

  // res 是响应对象，它包含了与服务器相关的数据和属性，例如：
  // 为了防止中文显示乱码的问题，需要设置响应头
  res.setHeader('Content-Type', 'text/html; charset=utf8')

  // res.end()方法向客户端发生知道内容，并结束这次请求的处理过程
  res.end(str);
})

// 调用server.listen(端口号, cd回调) 方法， 即可启动web 服务器
server.listen(80, () => {
console.log('http server running at http://127.0.0.1')
})
```
可通过不同的url 地址提供不同的html 内容
```js
const http = require('http')

const server = http.createServer()

server.on('request', function (req, res) {
  // 1、获取请求的地址
  const url = req.url 

  // 2、设置默认内容为404 ...
  let content = '<h1>404 Not Found!</h1>' 

  if (url === '/' || url === '/index.html') {
    // 3、用户请求的是首页
    content = '<h1>首页</h1>' 
  } else if (url === '/about.html') {
    // 4、用户请求的是关于页面
    content = '<h1>关于页面</h1>' 
  }

  // 5、设置响应头，防止中文乱码
  res.setHeader('Content-Type', 'text/html; charset=utf8') 
  // 6、把内容发生给客户端
  res.end(content) 
})

server.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```
## 模块化
### Node.js中模块化
Node.js中根据模块来源的不同，将模块分为三大类：
- 1、内置模块：fs、path、http
- 2、自定义模块：用户创建的.js文件
- 3、第三方模块

#### 加载模块
使用强大的`require()`方法，可以讲三类模块加入进行使用：
```js
// 加载内置fs 模块
const fs = require('fs');

// 加载用户自定义模块
const custom = require('./custom.js')

// 导入自定义模块
// 均能正常导入
const Hi = require('./被导入模块.js')
const Hi = require('./被导入模块')

// 此方式不能正常导入
// const Hi = require('被导入模块.js')
// const Hi = require('被导入模块')


// 加载第三方模块
const moment = require('moment')
```
### npm与包
### 模块的加载机制